# 实验报告

# 实验一：进程调度

## 一、实验目的

1. 理解进程调度的重要性和内容
2. 加深对优先数法和时间片轮转法这两种算法的理解。
3. 编程实现着两种算法， 理解并掌握实施方法。
4. 加深对进程结构、功能、作用、运行的理解与掌握
5. 加深对进程状态的理解，并能清楚直到状态之间的变化。

## 二、实验原理

### （一）优先数法

算法描述：

1. 进程就绪队列按优先数大小从高到低排列，链首进程首先投入运行。进程每执行一次，进程需要的时间片数减1、该进程的优先数减3。
2. 这样，该进程如果在一个时间片中没有完成，其优先数降低一级。
3. 接着仍是用该进程降低一级后的优先数与就绪队列中链首进程的优先数进行比较，如果仍是该进程的优先数高或相同，便让该进程继续执行；
4. 否则，调度就绪队列的链首进程投入运行。
5. 原运行过的进程按其现行优先数大小插入就绪队列，且改变它们对应的进程状态，一直到所有进程都运行完各自的时间片数。

### （二）时间片轮转法

基本原理：

1. 先来先服务
2. 按照到达时间排序
3. 分配同样大小的时间片
4. 在这个时间片内，如果进程执行完毕，则从进程队列中删除；否则变为等待状态放到队尾。
5. 直到所有进程执行完毕

关于时间片：

- 太小：进程间切换频繁，浪费CPU资源
- 太大：退化成先来先服务算

具体实现过程：

进程就绪队列按各进程进入的先后顺序排列。

进程每次所需处理机的轮转式按其重要程度记入进程控制块中的轮转时间片数记录项。

进程执行时，每运行一个时间片：

- 进程还需要的时间片数减1
- 运行进程占用处理机的时间片数加1

然后比较占用CPU的时间片数是否与该进程的轮转时间片数相等，若相等则说明已达到轮转时间，应将现运行的进程排列就绪队列的末尾，调度队列上的首进程运行，且改变它们的进程状态

直至所有进程完成各自的时间片。

## 三、算法实现

### （1）时间片轮转法

```cpp
#include <iostream>
#include <cstring>
using namespace std;

struct PCB {
	char NAME[10]; 	/*进程名*/
	int ROUND; 		/*进程轮转时间片*/
	int REACHTIME; 	/*进程到达时间*/
	int CPUTIME; 	/*进程占用CPU时间*/
	int COUNT; 		/*计数器*/
	int NEEDTIME;	/*进程完成还要的CPU时间*/
	char STATE; 	/*进程的状态*/
	struct PCB *NEXT; /*链指针*/
};

struct LINK { /*PCB的链结构*/
	struct PCB *RUN; 	/*当前运行进程指针*/
	struct PCB *READY; 	/*就绪队列头指针*/
	struct PCB *TAIL; 	/*就绪队列尾指针*/
	struct PCB *FINISH; /*完成队列头指针*/
};

void INIT(LINK *); 		/*对PCB的链结构初始化*/
void INSERT(LINK *); 	/*将执行了一个单位时间片数且还未完成的进程的PCB插到就绪队列的队尾*/
void FIRSTIN(LINK *); 	/*将就绪队列中的第一个进程投入运行*/
void PRINT(LINK *); 	/*打印每执行一个时间片后的所有进程的状态*/
void PR(PCB *); 		/*打印一个进程的状态*/
int CREATE(LINK *,int); /*创建新的进程*/
void ROUNDSCH(LINK *); 	/*按时间片轮转法调度进程*/

int main() {
	LINK pcbs;
	int i;
	INIT(&pcbs);
	i=0;
	printf("创建2个进程\n\n");
	while(i<2) {
		if(CREATE(&pcbs,i+1)==1) {
			printf("Create Successfully!\n");
			i++;
		}
		else
			printf("Create failed!\n");
		}
		FIRSTIN(&pcbs);
		ROUNDSCH(&pcbs);
}

// 初始化PCB链结构 
void INIT(LINK *p) {
    p->RUN = NULL;	// 运行队列为空 
    
    p->TAIL = p->READY = (PCB *)new PCB;
    p->READY->NEXT = NULL;
    
	p->FINISH = (PCB *)new PCB;	// 完成队列为空 
    p->FINISH->NEXT = NULL;
}

// 创建进程 
int CREATE(LINK *p,int n) 
{
    PCB *pcb,*q;
    pcb = (PCB *) new PCB;
    
    pcb->CPUTIME = 0;
    pcb->COUNT = 0;
    printf("[name | round | startime | sumtime]: ");	// 进程 id | 轮转片数 | 到达时间 | 所需总时间 
    cin >> pcb->NAME >> pcb->ROUND >> pcb->REACHTIME >> pcb->NEEDTIME;
     
    if(strcmp(pcb->NAME,"") == 0 || pcb->ROUND <= 0 || pcb->NEEDTIME <= 0) return 0;	// 处理错误输入  
    
    pcb->STATE='W';	// 进程状态设置为等待， 放入等待队列 
    pcb->NEXT=NULL;	// 下一个节点指向null 
    q=p->READY;	// 等待队列的头指针 
    
    // 插入等待队列，按照到达时间排序 
    while(q->NEXT != NULL && q->NEXT->REACHTIME <= pcb->REACHTIME)
        q=q->NEXT;
    pcb->NEXT=q->NEXT;
    q->NEXT=pcb;
    
    // 就绪队列尾指针 
    if(pcb->NEXT==NULL)
        p->TAIL=pcb;
    return 1;
}

void ROUNDSCH(LINK *p) {
	PCB *pcb;
	while(p->RUN!=NULL) {
		
		pcb=(PCB *)new PCB;
		strcpy(pcb->NAME,p->RUN->NAME);
		pcb->ROUND = p->RUN->ROUND;	
		pcb->REACHTIME = p->RUN->REACHTIME;	
		pcb->CPUTIME = p->RUN->CPUTIME;	
		pcb->COUNT = p->RUN->COUNT;	
		pcb->NEEDTIME = p->RUN->NEEDTIME;	
		pcb->STATE = p->RUN->STATE;	
		pcb->NEXT = p->RUN->NEXT;	
		
		pcb->CPUTIME ++;	
		pcb->NEEDTIME --;	
		pcb->COUNT ++;	
		
		if(pcb->NEEDTIME == 0) 	// 处理完成 
		{
			pcb->NEXT = p->FINISH->NEXT;
			p->FINISH->NEXT = pcb;
			pcb->STATE = 'F';
			p->RUN = NULL;	
			if(p->READY != p->TAIL)	
				FIRSTIN(p);	
		}	
		else {	
			p->RUN = pcb;
			if(pcb->COUNT == pcb->ROUND) {
				pcb->COUNT = 0;
				if(p->READY != p->TAIL) {
					pcb->STATE = 'W';
					INSERT(p);
					FIRSTIN(p);
				}	
			}
		}
		PRINT(p);
	}
}

    
void FIRSTIN(LINK *p) {
    PCB *q;
    
	q=p->READY->NEXT;	// 等待队列第一个进程 
    p->READY->NEXT=q->NEXT;
    q->NEXT=NULL;		// 取出 
    
    if(p->READY->NEXT == NULL)
        p->TAIL = p->READY;
    
	q->STATE = 'R';	// 取出的进程状态为 RUN 
    p->RUN = q;  	// 运行队列 
}

// 一个单位时间片后，但是未完成的进程插入等待队列末尾 
void INSERT(LINK *p) {
    PCB *pcb;
    pcb=(PCB *)new PCB;
    
    strcpy(pcb->NAME, p->RUN->NAME);
    pcb->ROUND = p->RUN->ROUND;
    pcb->REACHTIME = p->RUN->REACHTIME;
    pcb->CPUTIME = p->RUN->CPUTIME;
    pcb->COUNT = p->RUN->COUNT;
    pcb->NEEDTIME = p->RUN->NEEDTIME;
    pcb->STATE = 'W';
    pcb->NEXT = p->RUN->NEXT;
    
    // 更新pcbs链结构 
    p->TAIL->NEXT=pcb;
    p->TAIL=pcb;
    p->RUN=NULL;
    
}

void PRINT(LINK *p) 
{
	puts("========================");
 
    PCB *pcb;   
    
	// 展示运行队列 
    if(p->RUN!=NULL)
        PR(p->RUN);
        
    // 展示等待队列 
    if(p->READY != p->TAIL) {
        pcb=p->READY->NEXT;
        while(pcb!=NULL) {
            PR(pcb);
            pcb=pcb->NEXT;
        }
    }
    
    pcb=p->FINISH->NEXT;
    
    // 运行完成的队列 
    while(pcb!=NULL) {
        PR(pcb);
        pcb=pcb->NEXT;
    }

}

void PR(PCB *p) {
	printf(" %c [id: %s | round: %d | usecpu: %d | needcpu: %d | counter: %d]\n", p->STATE, p->NAME, p->ROUND, p->CPUTIME, p->NEEDTIME, p->COUNT);

}
```

![Untitled](https://s1.vika.cn/space/2023/01/11/1f9c017225934efea11de0a4df264bf2)

### （2）优先数法

```cpp
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
typedef struct node
{
   char name[10];   /*进程标识符*/
   int prio;        /*进程优先数*/
   int cputime;     /*进程占用CPU时间*/
   int needtime;    /*进程到完成还要的时间*/
   int count;       /*计数器*/
   char state;      /*进程的状态*/
   struct node *next; /*链指针*/
}PCB;
PCB *finish,*ready,*tail,*run; /*队列指针*/

int N; /*进程数*/

/*将就绪队列中的第一个进程投入运行*/
void firstin()
{
    run=ready;   /*就绪队列头指针赋值给运行头指针*/
    run->state='R';   /*进程状态变为运行态*/
    ready=ready->next;  /*就绪对列头指针后移到下一进程*/
}

/*标题输出函数*/
void prt1()
{
    printf("  进程号   cpu时间  所需时间  优先数    状态\n");
}
/*进程PCB输出*/
void prt2(PCB *q)
{
    printf("  %-10s%-10d%-10d%-10d %c\n", q->name, q->cputime, q->needtime, q->prio, q->state);
}
/*输出函数*/
void prt()
{
    PCB *p;
    prt1();  /*输出标题*/
    if(run!=NULL) /*如果运行指针不空*/
        prt2(run); /*输出当前正在运行的PCB*/
    p=ready;  /*输出就绪队列PCB*/
    while(p!=NULL)
    {
        prt2(p);
        p=p->next;
    }
    p=finish;  /*输出完成队列的PCB*/
    while(p!=NULL)
    {
        prt2(p);
        p=p->next;
    }
    getchar();  /*压任意键继续*/
}
/*优先数的插入算法*/
void insert1(PCB *q)
{
    PCB *p1,*s,*r;
    int b;
    s=q;  /*待插入的PCB指针*/
    p1=ready; /*就绪队列头指针*/
    r=p1; /*r做p1的前驱指针*/
    b=1;
    while((p1!=NULL)&&b)  /*根据优先数确定插入位置*/
        if(p1->prio>=s->prio)
        {
            r=p1;
            p1=p1->next;
        }
        else
            b=0;
    if(r!=p1)  /*如果条件成立说明插入在r与p1之间*/
    {
        r->next=s;
        s->next=p1;
    }
    else
    {
        s->next=p1;  /*否则插入在就绪队列的头*/
        ready=s;
    }
}
/*优先数创建初始PCB信息*/
void create()
{
    PCB *p;
    int i,time;
    char na[10];
    ready=NULL; /*就绪队列头指针*/
    finish=NULL;  /*完成队列头指针*/
    run=NULL; /*运行队列指针*/
    printf("输入进程号和运行时间：\n"); /*输入进程标识和所需时间创建PCB*/
    for(i=1;i<=N;i++)
    {
        p=(PCB *)malloc(sizeof(PCB));
        scanf("%s",na);
        scanf("%d",&time);
        strcpy(p->name,na);
        p->cputime=0;
        p->needtime=time;
        p->state='w';
        p->prio=50-time;
        if(ready!=NULL) /*就绪队列不空调用插入函数插入*/
            insert1(p);
        else
        {
            p->next=ready; /*创建就绪队列的第一个PCB*/
            ready=p;
        }
    }
    printf("          优先数算法输出信息:\n");
    printf("************************************************\n");
    prt();  /*输出进程PCB信息*/
    run=ready; /*将就绪队列的第一个进程投入运行*/
    ready=ready->next;
    run->state='R';
}
/*优先数调度算法*/
void priority()
{
    while(run!=NULL)  /*当运行队列不空时，有进程正在运行*/
    {
        run->cputime=run->cputime+1;
        run->needtime=run->needtime-1;
        run->prio=run->prio-3; /*每运行一次优先数降低3个单位*/
        if(run->needtime==0)  /*如所需时间为0将其插入完成队列*/
        {
        run->next=finish;
        finish=run;
        run->state='F';    /*置状态为完成态*/
        run=NULL;          /*运行队列头指针为空*/
        if(ready!=NULL)    /*如就绪队列不空*/
        firstin();  /*将就绪对列的第一个进程投入运行*/
        }
        else /*没有运行完同时优先数不是最大，则将其变为就绪态插入到就绪队列*/
        if((ready!=NULL)&&(run->prio<ready->prio))
        {
        run->state='W';
        insert1(run);
        firstin(); /*将就绪队列的第一个进程投入运行*/
        }
        prt(); /*输出进程PCB信息*/
    }   
}

main()
{
    printf("输入进程数：\n");
    scanf("%d",&N); /*输入进程数*/
    create(); /*优先数法*/
    priority();
}
```

![Untitled](https://s1.vika.cn/space/2023/01/11/772dba7c7781409295be0d46db290945)

# 实验二：存储管理

## 一、实验目的

1. 了解提高内存管理的效率的方法
2. 理解虚拟存储技术并掌握几个主要的算法
3. 理解分区分配算法、回收算法、请求式分页分配算法原理。并编码模拟实现。

## 二、实验内容

### （一）分区分配算法

1. 建立分区描述器：分区描述器可根据自己编写程序的需要来建立，描述器本身所包含的内容以描述清楚内存分区情况为准。
2. 建立自由主存队列：针对两种不同的放置策略（首次适应和最佳适应）来建立相应的队列结构。
3. 用C语言编写实现首次适应算法和最佳适应算法的程序。
4. 用C语言编写回收算法。

### （二）请求式分页存储

本实验要求采用请求式分页存储算法，淘汰算法采用先进先出算法FIFO和最近最少使用页面淘汰算法（LRU）。

设逻辑空间大小为128K，页面尺寸分别为2、4、6、8、10、12、14、16K，内存容量为8至64页。

1. 先进先出算法FIFO：该算法的实质是选择作业中在主存驻留时间最长的一页淘汰，这种算法容易实现，例如分配一个作业的存储块数为m，则只需建立一张m个元素的队列表Q(0)、Q(1)、…、Q(m-1)和一个替换指针。这个队列是按页调入主存的一页。如图4-1所示，某时刻调入主存四个块，（即m=4），它们按页进入主存的先后顺序为4、5、1、2，当需要置换时，总是淘汰替换指针所指向的那一页。新调进的页面装入主存后，修改相应的队列元素，然后将替换指针往前移动，使其指向当前最老的一页。
    
    ![Untitled](https://s1.vika.cn/space/2023/01/11/c942adc793ac460ea205e5f7a0506316)
    
2. 最近最少使用页面淘汰算法（LRU）：这是一种经常使用的方法，有多种不同的实施方案。这里采用不断调整页表链的方法，即总是淘汰页表链链首的页面，而把新访问的页面插入链尾。如果当前调用页面已在页表内，则把它再次调整到链尾。这样就能保证最近使用的页面总处于靠近链尾部分，而不常使用的页面被移到链首，逐个被淘汰。
    
    ![Untitled](https://s1.vika.cn/space/2023/01/11/1c381a62feaf4e139a5dabb03c90bbe5)
    

## 三、实验原理

### （一）分区分配

**最佳适应算法：**

1. 首先，定义一个p指针，让p指针遍历空闲分区链表，当找到第一个满足进程请求空间大小的空闲区时，记录此位置，并且保存请求大小与空闲分区实际大小的差值记为a
2. 然后让p指针继续遍历空闲分区链表，每当满足请求内存大小小于空闲区大小时，就记录两者的差值并且记录为b，比较a与b的大小关系
    1. 当a>b时，将b的值赋予a，并且修改记录位置为此空闲区的位置。
    2. a<=b,不做操作。继续遍历链表
    
    重复上面的操作，直到p->next指向null为止。
    

**首次适应算法：**

只要找到满足条件的空闲区，就将此区的空间分配给进程。

1. 首先，用P指针遍历链表，找到第一个空间大于或者等于请求大小的位置，将此空间分配给进程
2. 当此空闲区大小大于请求空间大小时，将空闲区分为两部分。一部分分配给进程；另一部分为空闲区，它的大小为之前空闲区大小减去分配给进程的空间大小。

**内存回收算法：**

内存回收时，回收分区与空闲分区有四种关系。

1. 第一种情况为回收分区r上临一个空闲分区，此时应该合并为一个连续的空闲区，其始址为r上相邻的分区的首地址，而大小为两者大小之和。
2. 第二种情况为回收分区r与下相邻空闲分区，合并后仍然为空闲区，该空闲区的始址为回收分区r的地址，大小为两者之和
3. 第三种情况为回收部分r与上下空闲区相邻，此时将这三个区域合并，始址为r上相邻区域的地址，大小为三个分区大小之和。
4. 当回收部分r上下区域都为非空闲区域，此时建立一个新的空闲分区，并且加入到空闲区队列中去。

### （二）请求式分页

1. 虚拟存储系统
    
    UNIX中，为了提高内存利用率，提供了内外存进程对换机制；内存空间的分配和回收均以页为单位进行；一个进程只需将其一部分（段或页）调入内存便可运行；还支持请求调页的存储管理方式。
    
    当进程在运行中需要访问某部分程序和数据时，发现其所在页面不在内存，就立即提出请求（向CPU发出缺中断），由系统将其所需页面调入内存。这种页面调入方式叫请求调页。
    为实现请求调页，核心配置了四种数据结构：页表、页框号、访问位、修改位、有效位、保护位等。
    
2. 页面置换算法
    
    当CPU接收到缺页中断信号，中断处理程序先保存现场，分析中断原因，转入缺页中断处理程序。该程序通过查找页表，得到该页所在外存的物理块号。如果此时内存未满，能容纳新页，则启动磁盘I/O将所缺之页调入内存，然后修改页表。如果内存已满，则须按某种置换算法从内存中选出一页准备换出，是否重新写盘由页表的修改位决定，然后将缺页调入，修改页表。利用修改后的页表，去形成所要访问数据的物理地址，再去访问内存数据。整个页面的调入过程对用户是透明的。
    
    1. 先进先出的算法（FIFO）：选择在内存中驻留时间最久的页面予以替换。
    2. 最近最久未使用算法（LRU）：选择过去最长时间未被访问的页面予以替换。
    
    假设操作系统为某进程分配了三个内存块，分别以两种算法模拟页面置换过程。
    
    1. FIFO：缺页率 7/9
        
        ![Untitled](https://s1.vika.cn/space/2023/01/11/de8356030f1546c0adb89ee18f0f495d)
        
    2. LRU：缺页率：6/9
        
        ![Untitled](https://s1.vika.cn/space/2023/01/11/ff4b66e76a1d4bd09a2080fd073056b9)
        

## 四、算法实现

### （1）分区分配算法

源代码：

```cpp
#include <iostream>
using namespace std;

#define FREE 0
#define  BUSY 1
#define  MAX_length 640

typedef struct freeArea//首先定义空闲区分表结构
{
	int flag;
	int size;
	int ID;
	int address;
}Elemtype;

typedef struct Free_Node
{
	Elemtype date;
	struct Free_Node *front;
	struct Free_Node *next;
}Free_Node,*FNodeList;

FNodeList block_first;
FNodeList block_last;
int alloc(int tag);//内存分配
int free(int ID);//内存回收
int first_fit(int ID,int size);//首次适应算法
int best_fit(int ID,int size);//最佳适应算法
void show();//查看分配
void init();//初始化
void Destroy(Free_Node *p);//销毁节点

void init()//
{
	block_first=new Free_Node;
	block_last = new Free_Node;
	block_first->front=NULL;
	block_first->next=block_last;
	block_last->front=block_first;
	block_last->next=NULL;
	block_last->date.address=0;
	block_last->date.flag=FREE;
	block_last->date.ID=FREE;
	block_last->date.size=MAX_length;
}

//实现内存分配
int alloc(int tag)
{
	int ID,size1;
	cout<<"请输入作业号：";
	cin>>ID;
	cout<<"请输入所需内存大小：";
	cin>>size1;
	if (ID<=0 || size1<=0)
	{
		cout<<"ERROR,请输入正确的ID和请求大小"<<endl;
		return 0;
	}

	if (tag==1)//采用首次适应算法
	{
		if(first_fit(ID,size1))
		{
			cout<<"分配成功！"<<endl;
		}
		else cout<<"分配失败！"<<endl;
		return 1;
	}
	else
	{
		if (best_fit(ID,size1))
		{
			cout<<"分配成功！"<<endl;
		}
		else cout<<"分配失败！"<<endl;
		return 1;
	}

}

int first_fit(int ID,int size)//首次适应算法
{
	FNodeList temp=(FNodeList)malloc(sizeof(Free_Node));
	Free_Node *p=block_first->next;
	temp->date.ID=ID;
	temp->date.size=size;
	temp->date.flag=BUSY;
	while(p)
	{
		if (p->date.flag==FREE && p->date.size==size)//请求大小刚好满足
		{
			p->date.flag=BUSY;
			p->date.ID=ID;
			return 1;
			break;
		}
		if (p->date.flag==FREE && p->date.size>size)//说明还有其他的空闲区间
		{
			temp->next=p;
			temp->front=p->front;
			temp->date.address=p->date.address;
		  p->front->next=temp;
		  p->front=temp;
		  p->date.address=temp->date.address+temp->date.size;
		  p->date.size-=size;
		  return 1;
		  break;
		}
		p=p->next;
	}
	return 0;
}

int best_fit(int ID,int size)//最佳适应算法
{
	int surplus;//记录可用内存与需求内存的差值
	FNodeList temp=(FNodeList)malloc(sizeof(Free_Node));
	Free_Node *p=block_first->next;
	temp->date.ID=ID;
	temp->date.size=size;
	temp->date.flag=BUSY;
	Free_Node *q=NULL;//记录最佳位置
	while(p)//遍历链表，找到第一个可用的空闲区间将他给q
	{
		if (p->date.flag==FREE&&p->date.size>=size)
		{
			q=p;
			surplus=p->date.size-size;
			break;
		}
		p=p->next;
	}
	while(p)//继续遍历，找到更加合适的位置
	{
		if (p->date.flag==FREE&&p->date.size==size)
		{
			p->date.flag=BUSY;
			p->date.ID=ID;
			return 1;
			break;
		}
		if (p->date.flag==FREE&&p->date.size>size)
		{
			if (surplus>p->date.size-size)
			{
				surplus=p->date.size-size;
				q=p;
			}

		}
		p=p->next;
	}
	if (q==NULL)//如果没有找到位置
	{
		return 0;
	}
	else//找到了最佳位置
	{
		temp->next=q;
		temp->front=q->front;
		temp->date.address=q->date.address;
		q->front->next=temp;
		q->front=temp;
		q->date.size=surplus;
		q->date.address+=size;
		return 1;
	}
}

int free(int ID)//主存回收
{
	Free_Node *p=block_first->next;
	while(p)
	{
		if (p->date.ID==ID)//找到要回收的ID区域
		{
			p->date.flag=FREE;
			p->date.ID=FREE;
			//判断P与前后区域关系
			if (p->front->date.flag==FREE&&p->next->date.flag!=FREE)
			{
				p->front->date.size+=p->date.size;
				p->front->next=p->next;
				p->next->front=p->front;
			}
			if (p->front->date.flag!=FREE&&p->next->date.flag==FREE)
			{
				p->date.size+=p->next->date.size;
				if(p->next->next)
				{
					p->next->next->front=p;
				p->next = p->next->next;
				}
				else p->next=p->next->next;
			}
			if(p->front->date.flag==FREE&&p->next->date.flag==FREE)
			{
				p->front->date.size+=p->date.size+p->next->date.size;
				if(p->next->next)
				{
				p->next->next->front=p->front;
				p->front->next=p->next->next;
				}
				else p->front->next=p->next->next;
			}
			if(p->front->date.flag!=FREE&&p->next->date.flag!=FREE)
			{//

			}
			break;
		}
		p=p->next;
	}
	cout<<"回收成功！"<<endl;
	return 1;
}
void Destroy(Free_Node *p)
{

}
void show()
{
	cout<<"------------------"<<endl;
	cout<<"内存分配情况"<<endl;
	cout<<"------------------"<<endl;
	Free_Node *p=block_first->next;
	while(p)
	{
		cout<<"分区号：";
		if (p->date.ID==FREE)
		cout<<"FREE"<<endl;
		else cout<<p->date.ID;
		cout<<"起始地址："<<p->date.address<<endl;
		cout<<"内存大小："<<p->date.size<<endl;
		cout<<"分区状态：";
		if (p->date.flag==FREE)
			cout<<"空闲"<<endl;
		else
			 cout<<"已分配"<<endl;
		cout<<"------------------"<<endl;
		p=p->next;
	}
}

int main()
{
	int tag=0;
	int ID;
	init();
	cout<<"分区模拟："<<endl;
	while(tag!=5)
	{
		puts("============================================================");
		cout << "[1-首次适应算法，2-最佳适应算法，3-内存回收，4-显示内存状况，5-退出]" << endl;
		cin >> tag;
		switch(tag)
		{
			case 1:
				alloc(tag);
				break;
			case 2:
				alloc(tag);
				break;
			case 3:
				cout<<"输入需要回收的ID号: "<<endl;
				cin>>ID;
				free(ID);
				break;
			case 4:
				show();
				break;
		}
	}
}
```

结果展示：

1. 目前内存状况：
    
    ![Untitled](https://s1.vika.cn/space/2023/01/11/23c75910fe7a425c855c5878cac8a59c)
    
2. 进行首次适应算法，插入一块大小为 50 的内存。可以看到插入到了第一块空闲块。
    
    ![Untitled](https://s1.vika.cn/space/2023/01/11/27b55798a8894875b04a34974824165b)
    
3. 进行内存回收，将第一块的内存释放掉。可以看出回收成功。
    
    ![Untitled](https://s1.vika.cn/space/2023/01/11/3523de3aceaa40ae8903468f4fb7360c)
    
4.  接下来新型最佳适应算法，同样插入一块大小为50的块。可见插入了空闲空间大小为55的内存地址中。
    
    ![Untitled](https://s1.vika.cn/space/2023/01/11/c246b59d281c437da5e7279f92359099)
    

### （2）请求式分页存储

源代码：

```cpp
#include <iostream>
#include<stdlib.h>
#include<ctime>
using namespace std;

struct pageinformation
{
	int id;		// 页面号
	int visit;	// 被访问标记
};
pageinformation* block;	//物理块
pageinformation* page;	//页面
int pagenum;	//合并的页面数
int a[100];		//显示时用的数组

class pager
{
private:
	int count;//页面中断次数
	int change;//页面置换次数
	static const int blocknum = 3;
public:
	void convertopage()//分配页面
	{
		cout << "页面数量：";
		cin >> pagenum; cout << endl;
		cout << "输入值：";
		for (int i = 0; i < pagenum; i++)
		{
			cin >> a[i];
		}
		page = new pageinformation[pagenum];
		for (int i = 0; i < pagenum; i++)
		{
			page[i].id = a[i];
		}
	}
	void blockclear()//物理块分配初值
	{
		block = new pageinformation[3];
		for (int i = 0; i < 3; i++)
		{
			block[i].id = -1;
			block[i].visit = 0;
		}
	}
	int findspace()//查找是否有空闲块
	{
		for (int i = 0; i < blocknum; i++)
		{
			if (block[i].id == -1)
				return i;//找到
		}
		return -1;
	}
	int findexist(int curpage)//寻找内存中是否有该页面
	{
		for (int i = 0; i < blocknum; i++)
		{
			if (block[i].id == page[curpage].id)
			{
				return i;
			}
		}
		return -1;
	}
	int findreplace()//查找应予以置换的页面
	{
		int pos = 0;
		for (int i = 0; i < blocknum; i++)
		{
			if (block[i].visit >= block[pos].visit)
				pos = i;
		}
		return pos;
	}
	void showall()//显示整体置换完的页面
	{
		for (int i = 0; i < pagenum; i++)
		{
			cout<<"置换后的结果为： "<< a[i] << "  ";
			if (i / 4 == 0) cout << endl;
		}
		cout << endl;
	}
	void show()//显示置换完一次后的block
	{
		cout << "此次置换后的block中为：";
		for (int i = 0; i < blocknum; i++)
		{
			if (block[i].id != -1)
				 cout<< block[i].id << "  ";
		}
		cout << endl;
	}
	
	void FIFO()//先进先出算法
	{
		puts("\n================== fifo =================");
		int exist, space, position;
		double fifo_missrate = 0;
		count = 0;
		change = 0;
		for (int i = 0; i < pagenum; i++)
		{
			exist = findexist(i);
			if (exist != -1)
			{
				cout << "----------------------------" << endl;
				cout << "即将访问的页面是：" << page[i].id << ",内存中已存在该页面" << "\n\n";
				cout << "----------------------------" << endl;
			}
			else
			{
				count++;
				space = findspace();
				if (space != -1)
				{
					block[space] = page[i];
					show();
				}
				else
				{
					change++;
					position = findreplace();
					cout << "即将访问的页面是：" << page[i].id << ",将被置换出的页面是：" << block[position].id << "\n\n";
					block[position] = page[i];
					show();
				}
			}
			for (int i = 0; i < blocknum; i++)
			{
				block[i].visit++;//页面进入后，每再进入一个页面停留时间+1；
			}
		}
		fifo_missrate = (float)count / pagenum;
		cout << "缺页次数：" << count << endl;
		cout << "置换次数：" << change << endl;
		cout << "fifo缺页率为：" << fifo_missrate * 100 << "%" << endl;
		puts("=======================================");
	}
	void lur()//最近最久未使用或者最少使用置换算法
	{
		puts("\n=================== lur =================");
		int exist, space, position;
		double lur_missrate = 0;
		count = 0;
		change = 0;
		for (int i = 0; i < pagenum; i++)
		{
			exist = findexist(i);
			if (exist != -1)
			{
				cout << "----------------------------" << endl;
				cout << "即将访问的页面是：" << page[i].id << ",内存中已存在该页面" << "\n\n";
				cout << "----------------------------" << endl;
				block[exist].visit = 0;//每访问一次需要重置；
			}
			else
			{
				count++;
				space = findspace();
				if (space != -1)
				{
					block[space] = page[i];
					show();
				}
				else
				{
					change++;
					position = findreplace();
					cout << "即将访问的页面是：" << page[i].id << ",将被置换出的页面是：" << block[position].id << "\n\n";
					block[position] = page[i];
					show();
				}
			}
			for (int i = 0; i < blocknum; i++)
			{
				block[i].visit++;//页面进入后，每再进入一个页面停留时间+1；
			}
		}
		lur_missrate = (float)count / pagenum;
		cout << "缺页次数：" << count << endl;
		cout << "置换次数：" << change << endl;
		cout << "lur缺页率为：" << lur_missrate * 100 << "%" << endl;
		puts("=======================================");
	}
};

int main()
{
	pager test;
	test.blockclear();
	test.convertopage();

	test.FIFO();
	test.blockclear();
	test.lur();
}
```

实验结果：以上文的举例作为输入

![Untitled](https://s1.vika.cn/space/2023/01/11/d97288a577814c69bfa45b0602c3440e)

1. FIFO
    
    ![Untitled](https://s1.vika.cn/space/2023/01/11/2d738cdfce5748c18f83ab4c5fae0409)
    
2. LUR
    
    ![Untitled](https://s1.vika.cn/space/2023/01/11/4020c353c2b54b8980ec2a1890fd8e26)
    

# 实验三：死锁

## 一、实验目的

1. 了解动态分配系统资源的过程
2. 观察死锁发生的条件，理解死锁的概念。
3. 了解死锁发生的原因，初步掌握防止死锁、解除死锁的简单方法
4. 理解并掌握防止死锁的发生的算法。

## 二、实验内容

- 设计一个几个并发进程共享m个系统资源的系统。进程可动态的申请资源和释放资源，系统按各进程的申请动态的分配资源。
- 系统应能显示各进程申请和释放资源的过程，能显示系统动态分配资源的过程，便于观察和分析。
- 系统应能选择是否采用防止死锁的算法，应设计多种防止死锁的算法，并能任意选择其中任何一种投入运行，同时要求，在不采用防止死锁算法时观察死锁现象发生的过程，在使用防止死锁的算法时，了解在同样条件下防止死锁发生的过程。
- 本次实验的上机时间为2～4学时。
- 所有程序均应采用C语言编写程序，特别需要的部分可采用汇编语言便程序。

**具体要求：**

本次实验采用银行算法防止死锁的发生。设有3个并发进程共享10个系统资源。

在3个进程申请系统资源之和不超过10时，当然不可能发生死锁，因为各个进程资源都能满足。

在有一个进程申请的系统资源数超过10时，必然会发生死锁。应该排队这两种情况。

程序采用人工输入各进程的申请资源序列。

如果随机给各进程分配资源，就可能发生死锁，这也就是不采用防止死锁算法的情况。

假如，按照一定的规则，为各进程分配资源，就可以防止死锁的发生。

示例采用银行算法。这是一种犹如“瞎子爬山”的方法，即探索一步，前进一步，行不通，再往其它方向试探，直至爬上山顶。这种方法是比较保守的，所花的代价也不小。

## 三、实验原理

### 1. 死锁

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

### 2. 产生死锁的必要条件

1. 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
2. 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
3. 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
4. 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正      在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

### 3. 死锁避免

在系统设计、进程调度等方面注意如何能够不让这四个产生死锁的必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。

此外，也要防止进程在处于等待状态的情况下占用资源,在系统运行过程中，对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，若分配后系统可能发生死锁，则不予分配，否则予以分配 。因此，对资源的分配要给予合理的规划。

### 4. 银行家算法

银行家算法是避免死锁的一种重要方法。 

1. 背景
    
    在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。
    
    银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。
    
    在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。
    
2. 算法描述：
    1. 操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量
        1. 如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源
        2. 否则就推迟分配。
    2. 当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。
        1. 若超过则拒绝分配资源
        2. 若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量
            1. 若能满足则按当前的申请量分配资源
            2. 否则要推迟分配。

1. 算法举例：
    
    例：有5个进程{P1,P2,P3,P4,P5} 。4类资源{R1,R2,R3,R4} 各自数量为6、3、4、2
    
    T0时刻各进程分配资源情况如下
    
    ![Untitled](https://s1.vika.cn/space/2023/01/11/18fb5bc53cdc4e48af7235411f2b62e1)
    
    T0时刻为安全状态，存在安全序列{P4，P1，P2，P3，P5} 如下
    
    ![Untitled](https://s1.vika.cn/space/2023/01/11/a357ae08a93e4fcdbe38a7fd1bc63123)
    

银行家算法在避免死锁角度上非常有效，但是需要在进程运行前就知道其所需资源的最大值，且进程数也通常不是固定的，因此使用有限。

## 四、算法实现

源代码：

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int N = 11, M = 22;	// 进程数、资源数

int max_need[N][M];     // 进程i最大需要第j种资源的数量
int need[N][M];		    // 进程i目前需要第j种资源的数量
int avliable[M];        // 当前第i种资源可用个数
int allocation[N][M];   // 进程i目前分配到的第j种资源的数量

int req[M];
int work[M];

vector<int> ans;

int n, m;

void show_1(int n, int a[])
{
    for (int i = 1; i <= n; i ++)
        cout << a[i] << ' ';
    cout << endl;
}

void show_2(int a[N][M])
{
	for (int i = 1; i <= n; i ++)
	{
		for (int j = 1; j <= m; j ++)
			cout << a[i][j] << ' ';
		cout << endl;
	}
}

void show()
{
//	printf("          |    max_need    |    allocation    |    need    |\n");
//	printf("  进程名  |     c1  c2     |      c1  c2      |   c1  c2   |\n");
	puts("************************************************");
	printf("----aviliable----\n");   show_1(m, avliable);
	printf("----max_need----\n");    show_2(max_need);
	printf("---allocation---\n");    show_2(allocation);
	printf("----  need  ----:\n");   show_2(need);
}

int safe()
{
    ans.clear();
    bool finish[M] = {0};
    for (int i = 1; i <= m; i ++) work[i] = avliable[i];
    for (int i = 1; i <= n; i ++)
    {
        int satisfy = 0;  // 当前进程有多少个资源是满足的
        for (int j = 0; j <= m; j ++)
        {
            if (finish[i] == false && need[i][j] <= work[j])
            {
                satisfy ++;
                if (satisfy == m)   // 全部满足，释放资源
                {
                    for (int k = 1; k <= m; k ++)
                    {
                        work[k] += allocation[i][k];
                    }
                    finish[i] = true;
                    ans.push_back(i);
                    i = 0;
                }
            }
        }
    }
    for (int i = 1; i <= n; i ++)
    {
        if (finish[i] == false)
        {
            puts("System danger!");
            return 0;
        }
    }
    puts("System Safe!");
    printf("Safe link: ");
    for (int i = 0; i < ans.size(); i ++) cout << ans[i] << (i == ans.size()-1 ? "" : "->");
    cout << endl;
    return 1;
}

void test(int i)
{
    for (int j = 1; j <= m; j ++)
    {
        avliable[j] -= req[j];
        allocation[i][j] += req[j];
        need[i][j] -= req[j];
    }
    return ;
}

void bank()
{
    printf("申请资源进程号(1-%d):", n);
    int i; cin >> i;
    printf("对m类资源分别需求个数: \n");
    for (int j = 1; j <= m; j ++)
    {
        cout << j << "_th: ";
        cin >> req[j];
    }
    
    
    int flag = 1;   // 能分配成功
    
    for (int j = 1; j <= m; j ++)
    {
        if (req[j] > need[i][j])
        {
            cout << "大于需求，ERROR！" << endl;
            flag = 0;
            break;
        }
        else if (req[j] > avliable[j])
        {
            cout << "大于可用，ERROR！" << endl;
            flag = 0;
            break;
        }
    }
    if (flag)
    {
        test(i);
        show();
        safe();
    }
}

void init()
{
	printf("[p_num | c_num]: ");
	scanf("%d%d", &n, &m);
	
	printf("avliable[1 * %d]\n", m);
	for (int i = 1; i <= m; i ++)
	{
		cin >> avliable[i];
	}
//	printf("init_aviliable:\n");   show_1(m, avliable); 
	
	
 	printf("max_need[%d * %d]\n", n, m);
	for (int i = 1; i <= n; i ++)
	{
		for (int j = 1; j <= m; j ++)
		{
			cin >> max_need[i][j];
		}
	}
//	printf("\nmax_need:\n");    show_2(max_need);
	
	bool flag = true;	// 符合要求  
 	printf("allocation[%d * %d]\n", n, m);
	for (int i = 1; i <= n; i ++)
	{
		for (int j = 1; j <= m; j ++)
		{
		    int x; cin >> x;
		    avliable[j] -= x;
			allocation[i][j] = x;
			need[i][j] = max_need[i][j] - allocation[i][j];
			if (need[j][j] < 0) flag = false;
		}
	}
	
	if (!flag) 
	{
		printf("Init Error!\n");
		return ;
	}
	
	printf("------------Init Success!------------\n");
}

int main()
{
	init(); 
	show();
	safe();
	
	while(1)
	{
	    printf("[request(r) | exit(e)]: ");
	    char op[2];
	    cin >> op;
	    if (*op == 'r')
	    {
	        bank();
	    }
	    else if (*op == 'e')
	    {
	        puts("==========EXIT=========");
	        break;
	    }
	}
	return 0;
}
```

结果分析：

1. 如果资源请求资源数大于总资源数，那么不能成功分配。
	-  ![image.png](https://s1.vika.cn/space/2023/01/11/2e1fb69a166943859b1f44f67e4b457d)
2. 如果能够初始化，则判断是否能够成安全序列
	- ![image.png](https://s1.vika.cn/space/2023/01/11/595932bdf18c49b8a2625c99fb7f9085) 
3. 进行资源的申请与分配，如果成功则分配资源，不成功则输出报错信息。
	- 成功
		- ![image.png](https://s1.vika.cn/space/2023/01/11/62f3de54c5b84ac5b4e24438b7472b25)

	- 失败
		- ![image.png](https://s1.vika.cn/space/2023/01/11/118257d52f684cc7a890bd741128df31)



# 实验四：文件系统

## 一、实验目的

1. 了解文件系统的概念与意义
2. 理解并掌握文件系统的工作过程
3. 理解并掌握各种文件操作命令的实质内容和执行过程
4. 编写代码实现简单的文件系统，提升对文件系统的认知和实际动手能力。

## 二、实验内容

- 设计一个n个用户的文件系统，每个用户最多可保存m个文件。
- 限制用户在一次运行中只能打开一个文件。
- 系统应能检查输入命令的正确性，出错时要能显示出错原因。
- 对文件必须设置保护措施，如只能执行，允许读，允许写等。在每次打开文件时，根据本次打开的要求，再次设置保护级别，即可有二级保护。
- 对文件的操作至少应有下面几条命令：
    
    `create`    建立文件
    
    `delete`    删除文件
    
    `open`      打开文件
    
    `close`     关闭文件
    
    `read`      读文件
    
    `write`     写文件
    

### 详细要求

- 本次实验设计一个共有10个用户的文件系统，每个用户最多可保存10个文件，一次运行过程中用户可同时打开5个文件。
- 程序采用二级文件目录，即设置了主文件目录（MFD）和用户文件目录（UFD）。前者应包含文件主（即用户）及他们的目录区指针；后者应给出每个文件主占有的文件目录，即文件名、保护码、文件长度以及它们存放的位置等。另外为打开文件设置了运行文件目录（AFD），在文件打开时应填入打开文件号，本次打开保护码和读写指针等。
- 为了便于实现，对文件的读写作了简化，在执行读写命令时，只修改读写指针，并不进行实际文件的读写操作。

## 三、实验原理

- 因系统小，文件目录的检索使用了简单的线性搜索，而没有采用Hash等有效算法。
- 文件保护简单使用了三位保护码，对应于允许读，允许写和允许执行，如下所示：
    ![](https://s1.vika.cn/space/2023/01/11/5479549a76ea44b6927006acbe63b7e8)
    
- 程序中使用的主要数据结构如下：
    - 主文件目录（MFD）和用户文件目录（UFD）
        ![](https://s1.vika.cn/space/2023/01/11/6d0e8eb9fc624151af5624fe49bb21ec)
        
    - 打开文件目录（AFD）
        ![](https://s1.vika.cn/space/2023/01/11/6746b8e4c33f439fb68f30cb2efe641b)
        

**程序框图**
![](https://s1.vika.cn/space/2023/01/11/0fe9137ee31f4d1eabfbd64761995c40)
![](https://s1.vika.cn/space/2023/01/11/0ecace7b564b4c0caaff90355e039cd4)
## 四、算法实现

### 源代码

```cpp
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <iostream>
using namespace std;
#include <time.h>

typedef struct fileContent
{
    // 实际文件内容
    string Content;
} *FileContent;

typedef struct file
{
    string fileName;    // 文件名
    string fileType;    // 文件类型
    int fileSize;   // 文件大小
    FileContent fileContent;    // 文件内容指针
    // 文件保护码（index = 0：读权限，index = 1：读权限，index = 2：执行权限；权限位含义：0为禁止，1为允许）
    char fileProtectCode[3];
    time_t createTime;  // 创建时间
    time_t updateTime;  // 修改时间
    time_t accessTime;  // 访问时间
} *File;

// 二级目录：用户文件目录（每个用户的独立文件目录）
typedef struct uFD
{
    File file;  // 当前文件
    uFD *before;    // 上一个文件指针
    uFD *next;  // 下一个文件指针
} *UFD;

typedef struct user
{
    string username;    // 用户名
    string password;    // 密码
    UFD ufd;    // 用户目录指针
} *User;

// 一级目录：主文件目录（所有用户和对应用户的相关信息）
typedef struct mFD
{
    User user;  // 当前用户
    mFD *before;    // 上一个用户指针
    mFD *next;  // 下一个用户指针
} *MFD;

// 打开文件目录（运行文件目录）
typedef struct aFD
{
    File file;  // 当前文件
    aFD *before;    // 上一个文件指针
    aFD *next;  // 下一个文件指针
} *AFD;

// 初始化一级目录（主文件目录：所有用户和对应用户的相关信息）
void initMFD (MFD &mfd)
{
    mfd = new(mFD);
    mfd->user = NULL;
    mfd->before = NULL;
    mfd->next = NULL;
}

// 初始化二级目录（用户文件目录：每个用户的独立文件目录）
void initUFD (UFD &ufd)
{
    ufd = new(uFD);
    ufd->file = NULL;
    ufd->before = NULL;
    ufd->next = NULL;
}

// 初始化打开文件目录（运行文件目录）
void initAFD (AFD &afd)
{
    afd = new(aFD);
    afd->file = NULL;
    afd->before = NULL;
    afd->next = NULL;
}

// 初始化
void init (MFD &mfd, AFD &afd, User &currentUser)
{
    initMFD(mfd);
    initAFD(afd);
    currentUser = NULL;
}

// 创建二级目录（用户文件目录：每个用户的独立文件目录）
UFD createUFD ()
{
    UFD ufd = new(uFD);
    initUFD(ufd);
    return ufd;
}

// 创建打开文件目录（运行文件目录）
AFD createAFD ()
{
    AFD afd = new(aFD);
    initAFD(afd);
    return afd;
}

// 判断用户是否存在（已被创建过）
bool isExistForUser (MFD &mfd, string useranme)
{
    MFD tempMFD = mfd->next;
    while (tempMFD != NULL)
    {
        if (strcmp(tempMFD->user->username.c_str(), useranme.c_str()) == 0)
        {
            return true;
        }
        tempMFD = tempMFD->next;
    }
    return false;
}

// 创建用户
void createUser (MFD &mfd)
{
    string username;
    cout<<"请输入用户名：";
    getline(cin, username);
    if (isExistForUser(mfd, username))
    {
        cout<<username + "用户已存在，创建失败！"<<endl;
        return;
    }
    cout<<"用户名“" + username + "”可用！"<<endl;
    string password;
    cout<<"请输入密码：";
    getline(cin, password);
    User newUser = new(user);
    newUser->username = username;
    newUser->password = password;
    newUser->ufd = createUFD();
    MFD newMFDNode = new(mFD);
    newMFDNode->user = newUser;
    MFD tempMFD = mfd;
    while (tempMFD->next != NULL)
    {
        tempMFD = tempMFD->next;
    }
    tempMFD->next = newMFDNode;
    newMFDNode->before = tempMFD;
    newMFDNode->next = NULL;
    mfd->before = newMFDNode;
    cout<<"创建" + username + "用户成功！"<<endl;
}

// 删除用户
void deleteUser (MFD &mfd)
{
    cout<<"正在删除用户......"<<endl;
    if (mfd->next == NULL)
    {
        cout<<"一级目录（主文件目录：所有用户和对应用户的相关信息）为空！无用户！此操作无效！"<<endl;
        return;
    }
    else
    {
        string username;
        string password;
        cout<<"请输入用户名：";
        getline(cin, username);
        MFD tempMFD = mfd->next;
        do
        {
            if (strcmp(tempMFD->user->username.c_str(), username.c_str()) == 0)
            {
                cout<<"正在递归删除" + tempMFD->user->username + "用户的相关信息和所有文件......"<<endl;
                UFD tempUFD = tempMFD->user->ufd;
                while (tempUFD->next != NULL)
                {
                    tempUFD = tempUFD->next;
                    delete(tempUFD->before);
                    tempUFD->before = NULL;
                }
                delete(tempUFD);
                tempUFD = NULL;
                tempMFD->before->next = tempMFD->next;
                if (tempMFD->next != NULL)
                {
                    tempMFD->next->before = tempMFD->before;
                }
                else
                {
                    mfd->before = tempMFD->before;
                }
                delete(tempMFD);
                tempMFD = NULL;
                cout<<"删除" + username + "用户成功！"<<endl;
                return;
            }
            tempMFD = tempMFD->next;
        }
        while (tempMFD != NULL);
        cout<<"没有匹配到相应用户！"<<endl;
        return;
    }
}

// 显示一级目录（主文件目录：所有用户和对应用户的相关信息）
void showMFD (MFD &mfd)
{
    cout<<endl;
    cout<<"显示一级目录（主文件目录：所有用户和对应用户的相关信息）:"<<endl;
    if (mfd->next == NULL)
    {
        cout<<"用户列表为空！无用户！"<<endl;
        return;
    }
    else
    {
        cout<<"用户列表："<<endl;
        MFD tempMFD = mfd->next;
        do
        {
            cout<<"\t" + tempMFD->user->username<<endl;
            tempMFD = tempMFD->next;
        }
        while (tempMFD != NULL);
    }
}

// 登录
void loginIn (MFD &mfd, User &currentUser)
{
    if (mfd->next == NULL)
    {
        cout<<"一级目录（主文件目录：所有用户和对应用户的相关信息）为空！无用户！此操作无效！"<<endl;
        return;
    }
    else
    {
        string username;
        cout<<"请输入用户名：";
        getline(cin, username);
        MFD tempMFD = mfd->next;
        do
        {
            if (strcmp(tempMFD->user->username.c_str(), username.c_str()) == 0)
            {
                string password;
                cout<<"请输入密码：";
                getline(cin, password);
                if (strcmp(tempMFD->user->password.c_str(), password.c_str()) != 0)
                {
                    cout<<"密码错误！登录失败！"<<endl;
                    return;
                }
                currentUser = tempMFD->user;
                cout<<"登录" + currentUser->username + "用户成功！"<<endl;
                cout<<endl;
                return;
            }
            tempMFD = tempMFD->next;
        }
        while (tempMFD != NULL);
        cout<<"没有匹配到相应用户！"<<endl;
        return;
    }
}

// 登出/注销登录
void loginOut (AFD &afd, User &currentUser)
{
    if (currentUser == NULL)
    {
        cout<<"无用户登录！此操作无效！"<<endl;
        return;
    }
    else
    {
        cout<<"为确保账户安全、文件信息的一致性，正在关闭已打开的文件......"<<endl;
        AFD tempAFD = afd->next;
        if (tempAFD != NULL)
        {
            while (tempAFD->next != NULL)
            {
                tempAFD = tempAFD->next;
                delete(tempAFD->before);
                tempAFD->before = NULL;
            }
            delete(tempAFD);
            tempAFD = NULL;
        }
        afd->before = afd->next = NULL;
        cout<<"已打开的文件已全部关闭！"<<endl;
        currentUser = NULL;
        cout<<"登出/注销登录成功！";
    }
}

// 获取完整文件名（文件名和文件类型）
string getFileNameWithType (File &file)
{
    string fileNameWithType = file->fileName + "." + file->fileType;
    return fileNameWithType;
}

// 判断完整文件名（文件名和文件类型）是否存在（已被创建过）
bool isExistForFile (UFD &ufd, string fileNameWithType)
{
    UFD tempUFD = ufd->next;
    while (tempUFD != NULL)
    {
        if (strcmp(getFileNameWithType(tempUFD->file).c_str(), fileNameWithType.c_str()) == 0)
        {
            return true;
        }
        tempUFD = tempUFD->next;
    }
    return false;
}

// 创建文件
void createFile (UFD &ufd)
{
    cout<<endl;
    cout<<"正在创建新文件......"<<endl;
    File newFile = new(file);
    cout<<"请输入文件名（不包含文件类型/文件扩展名）：";
    getline(cin, newFile->fileName);
    cout<<"请输入文件类型(不含.)：";
    getline(cin, newFile->fileType);
    cout<<"校验文件存在性中......"<<endl;
    if (isExistForFile(ufd, getFileNameWithType(newFile)))
    {
        cout<<newFile->fileName + "." + newFile->fileType + "文件已存在，创建失败！"<<endl;
        return;
    }
    newFile->fileSize = 0;
    newFile->fileContent = new(fileContent);
    newFile->fileContent->Content = "";
    // 设定文件类型如果为exe则文件保护码中可执行位设定为1
    if (strcmp(newFile->fileType.c_str(), "exe") == 0)
    {
        strcpy(newFile->fileProtectCode, "111");
    }
    else
    {
        strcpy(newFile->fileProtectCode, "110");
    }
    time(&newFile->createTime);
    newFile->updateTime = newFile->createTime;
    newFile->accessTime = newFile->createTime;
    UFD newUFDNode = createUFD();
    newUFDNode->file = newFile;
    UFD tempUFD = ufd;
    while (tempUFD->next != NULL)
    {
        tempUFD = tempUFD->next;
    }
    tempUFD->next = newUFDNode;
    newUFDNode->before = tempUFD;
    ufd->before = newUFDNode;
    cout<<"创建" + newFile->fileName + "." + newFile->fileType + "文件成功！"<<endl;
}

// 显示二级目录（用户文件目录：每个用户的独立文件目录）
void showUFD (UFD &ufd)
{
    cout<<endl;
    cout<<"显示二级目录（用户文件目录：每个用户的独立文件目录）："<<endl;
    if (ufd->next == NULL)
    {
        cout<<"文件列表为空！无文件！"<<endl;
        return;
    }
    else
    {
        cout<<"文件列表："<<endl;
        UFD tempUFD = ufd->next;
        do
        {
            printf("\t%s.%s\n", tempUFD->file->fileName.c_str(), tempUFD->file->fileType.c_str());
            tempUFD = tempUFD->next;
        }
        while (tempUFD != NULL);
    }
}

// 详细显示二级目录（用户文件目录：每个用户的独立文件目录）
void showUFDDetail (UFD &ufd)
{
    cout<<endl;
    cout<<"详细显示二级目录（用户文件目录：每个用户的独立文件目录）:"<<endl;
    if (ufd->next == NULL)
    {
        cout<<"文件列表为空！无文件！"<<endl;
        return;
    }
    else
    {
        UFD tempUFD = ufd->next;
        do
        {
            cout<<getFileNameWithType(tempUFD->file) + "文件详情："<<endl;
            cout<<"\t文件名：" + tempUFD->file->fileName<<endl;
            cout<<"\t文件类型：" + tempUFD->file->fileType<<endl;
            printf("\t文件大小：%d\n", tempUFD->file->fileSize);
            printf("\t文件保护码：%s\n", tempUFD->file->fileProtectCode);
            struct tm *lt;
            lt = localtime(&tempUFD->file->createTime);
            printf ("\t创建时间：%d/%d/%d %d:%d:%d\n",lt->tm_year + 1900, lt->tm_mon + 1, lt->tm_mday, lt->tm_hour, lt->tm_min, lt->tm_sec);
            lt = localtime(&tempUFD->file->updateTime);
            printf ("\t修改时间：%d/%d/%d %d:%d:%d\n",lt->tm_year + 1900, lt->tm_mon + 1, lt->tm_mday, lt->tm_hour, lt->tm_min, lt->tm_sec);
            lt = localtime(&tempUFD->file->accessTime);
            printf ("\t访问时间：%d/%d/%d %d:%d:%d\n",lt->tm_year + 1900, lt->tm_mon + 1, lt->tm_mday, lt->tm_hour, lt->tm_min, lt->tm_sec);
            tempUFD = tempUFD->next;
        }
        while (tempUFD != NULL);
    }
}

// 显示打开文件目录（运行文件目录）
void showAFD (AFD &afd)
{
    cout<<endl;
    cout<<"显示打开文件目录（运行文件目录）："<<endl;
    if (afd->next == NULL)
    {
        cout<<"已打开文件列表为空！无文件！"<<endl;
        return;
    }
    else
    {
        cout<<"已打开文件列表："<<endl;
        AFD tempAFD = afd->next;
        do
        {
            printf("\t%s.%s\n", tempAFD->file->fileName.c_str(), tempAFD->file->fileType.c_str());
            tempAFD = tempAFD->next;
        }
        while (tempAFD != NULL);
    }
}

// 详细打开文件目录（运行文件目录）
void showAFDDetail (AFD &afd)
{
    cout<<endl;
    cout<<"详细显示打开文件目录（运行文件目录）："<<endl;
    if (afd->next == NULL)
    {
        cout<<"已打开文件列表为空！无文件！"<<endl;
        return;
    }
    else
    {
        AFD tempAFD = afd->next;
        do
        {
            cout<<getFileNameWithType(tempAFD->file) + "已打开文件详情："<<endl;
            cout<<"\t文件名：" + tempAFD->file->fileName<<endl;
            cout<<"\t文件类型：" + tempAFD->file->fileType<<endl;
            printf("\t文件大小：%d\n", tempAFD->file->fileSize);
            printf("\t文件保护码：%s\n", tempAFD->file->fileProtectCode);
            struct tm *lt;
            lt = localtime(&tempAFD->file->createTime);
            printf ("\t创建时间：%d/%d/%d %d:%d:%d\n",lt->tm_year + 1900, lt->tm_mon + 1, lt->tm_mday, lt->tm_hour, lt->tm_min, lt->tm_sec);
            lt = localtime(&tempAFD->file->updateTime);
            printf ("\t修改时间：%d/%d/%d %d:%d:%d\n",lt->tm_year + 1900, lt->tm_mon + 1, lt->tm_mday, lt->tm_hour, lt->tm_min, lt->tm_sec);
            lt = localtime(&tempAFD->file->accessTime);
            printf ("\t访问时间：%d/%d/%d %d:%d:%d\n",lt->tm_year + 1900, lt->tm_mon + 1, lt->tm_mday, lt->tm_hour, lt->tm_min, lt->tm_sec);
            tempAFD = tempAFD->next;
        }
        while (tempAFD != NULL);
    }
}

// 检查读权限
bool checkReadablePermission (File &file)
{
    if (file->fileProtectCode[0] == '1')
    {
        return true;
    }
    else
    {
        return false;
    }
}

// 检查写权限
bool checkWritablePermission (File &file)
{
    if (file->fileProtectCode[1] == '1')
    {
        return true;
    }
    else
    {
        return false;
    }
}

// 检查执行权限
bool checkExecutablePermission (File &file)
{
    if (file->fileProtectCode[2] == '1')
    {
        return true;
    }
    else
    {
        return false;
    }
}

// 判断文件是否打开
File isOpen (AFD &afd, string fileNameWithType)
{
    AFD tempAFD = afd->next;
    while (tempAFD != NULL)
    {
        if (strcmp(getFileNameWithType(tempAFD->file).c_str(), fileNameWithType.c_str()) == 0)
        {
            return tempAFD->file;
        }
        tempAFD = tempAFD->next;
    }
    return NULL;
}

// 删除文件
void deleteFile (UFD &ufd, AFD &afd)
{
    cout<<endl;
    cout<<"删除文件中......"<<endl;
    if (ufd->next == NULL)
    {
        cout<<"二级目录（用户文件目录：每个用户的独立文件目录）为空！无文件！此操作无效！"<<endl;
        return;
    }
    else
    {
        string fileNameWithType;
        cout<<"请输入要删除的文件（格式：文件名.文件类型）：";
        getline(cin, fileNameWithType);
        cout<<"检索文件中......"<<endl;
        if (isOpen(afd, fileNameWithType))
        {
            cout<<"此文件已打开，不可删除！"<<endl;
            return;
        }
        UFD tempUFD = ufd->next;
        do
        {
            if (strcmp(getFileNameWithType(tempUFD->file).c_str(), fileNameWithType.c_str()) == 0)
            {
                cout<<"已匹配到对应文件，正在删除......"<<endl;
                if (!checkWritablePermission(tempUFD->file))
                {
                    cout<<"权限不足，该文件不可删除！"<<endl;
                    return;
                }
                tempUFD->before->next = tempUFD->next;
                if (tempUFD->next != NULL)
                {
                    tempUFD->next->before = tempUFD->before;
                }
                else
                {
                    ufd->before = tempUFD->before;
                }
                delete(tempUFD);
                tempUFD = NULL;
                cout<<"删除" + fileNameWithType + "文件成功！"<<endl;
                return;
            }
            tempUFD = tempUFD->next;
        }
        while (tempUFD != NULL);
        cout<<"没有匹配到相应文件！"<<endl;
        return;
    }
}

// 打开文件（加载到内存中）
void openFile (UFD &ufd, AFD &afd)
{
    cout<<endl;
    cout<<"打开文件中（加载到内存中）......"<<endl;
    if (ufd->next == NULL)
    {
        cout<<"二级目录（用户文件目录：每个用户的独立文件目录）为空！无文件！此操作无效！"<<endl;
        return;
    }
    else
    {
        string fileNameWithType;
        cout<<"请输入要打开/执行的文件（格式：文件名.文件类型）：";
        getline(cin, fileNameWithType);
        cout<<"检索文件中......"<<endl;
        if (isOpen(afd, fileNameWithType))
        {
            cout<<"此文件已打开（已加载至内存中），无需再次打开！"<<endl;
            return;
        }
        else
        {
            UFD tempUFD = ufd->next;
            do
            {
                if (strcmp(getFileNameWithType(tempUFD->file).c_str(), fileNameWithType.c_str()) == 0)
                {
                    cout<<"已匹配到对应文件，正在打开......"<<endl;
                    if (!checkReadablePermission(tempUFD->file) && checkWritablePermission(tempUFD->file) && !checkExecutablePermission(tempUFD->file))
                    {
                        cout<<"权限不足，该文件不可打开（加载到内存中）！"<<endl;
                        return;
                    }
                    AFD newAFDNode = createAFD();
                    newAFDNode->file = tempUFD->file;
                    AFD tempAFD = afd;
                    while (tempAFD->next != NULL)
                    {
                        tempAFD = tempAFD->next;
                    }
                    tempAFD->next = newAFDNode;
                    newAFDNode->before = tempAFD;
                    afd->before = newAFDNode;
                    cout<<"打开（加载到内存中）" + fileNameWithType + "文件成功！"<<endl;
                    return;
                }
                tempUFD = tempUFD->next;
            }
            while (tempUFD != NULL);
            cout<<"没有匹配到相应文件！"<<endl;
            return;
        }
    }
}

// 关闭文件
void closeFile (UFD &ufd, AFD &afd)
{
    cout<<endl;
    cout<<"关闭文件中......"<<endl;
    if (ufd->next == NULL)
    {
        cout<<"二级目录（用户文件目录：每个用户的独立文件目录）为空！无文件！此操作无效！"<<endl;
        return;
    }
    else
    {
        string fileNameWithType;
        cout<<"请输入要关闭的文件（格式：文件名.文件类型）：";
        getline(cin, fileNameWithType);
        cout<<"检索文件中......"<<endl;
        AFD tempAFD = afd->next;
        while (tempAFD != NULL)
        {
            if (strcmp(getFileNameWithType(tempAFD->file).c_str(), fileNameWithType.c_str()) == 0)
            {
                tempAFD->before->next = tempAFD->next;
                if (tempAFD->next != NULL)
                {
                    tempAFD->next->before = tempAFD->before;
                }
                else
                {
                    afd->before = tempAFD->before;
                }
                delete(tempAFD);
                tempAFD = NULL;
                cout<<"关闭" + fileNameWithType + "文件成功！"<<endl;
                return;
            }
            tempAFD = tempAFD->next;
        }
        cout<<"此文件未打开，无需关闭！"<<endl;
        return;
    }
}

// 读文件
void readFile (UFD &ufd, AFD &afd)
{
    cout<<endl;
    cout<<"读文件中......"<<endl;
    if (ufd->next == NULL)
    {
        cout<<"二级目录（用户文件目录：每个用户的独立文件目录）为空！无文件！此操作无效！"<<endl;
        return;
    }
    else
    {
        string fileNameWithType;
        cout<<"请输入要读取的文件（格式：文件名.文件类型）：";
        getline(cin, fileNameWithType);
        cout<<"正在检索文件中......"<<endl;
        File file = isOpen(afd, fileNameWithType);
        if (!file)
        {
            cout<<"没有匹配到相应文件（此文件还未打开，请先打开该文件再读！）"<<endl;
            return;
        }
        cout<<"已匹配到对应文件，正在尝试读......"<<endl;
        if (!checkReadablePermission(file))
        {
            cout<<"权限不足，该文件不可读！"<<endl;
            return;
        }
        // 修改文件访问时间
        time(&file->accessTime);
        cout<<"读" + fileNameWithType + "文件成功！"<<endl;
        if (file->fileSize == 0)
        {
            cout<<"文件内容：(无文件内容)" + file->fileContent->Content<<endl;
        }
        else
        {
            cout<<"文件内容：" + file->fileContent->Content<<endl;
        }
        return;
    }
}

// 写文件
void writeFile (UFD &ufd, AFD &afd)
{
    cout<<endl;
    cout<<"写文件中......"<<endl;
    if (ufd->next == NULL)
    {
        cout<<"二级目录（用户文件目录：每个用户的独立文件目录）为空！无文件！此操作无效！"<<endl;
        return;
    }
    else
    {
        string fileNameWithType;
        cout<<"请输入要写入的文件（格式：文件名.文件类型）：";
        getline(cin, fileNameWithType);
        cout<<"正在检索文件中......"<<endl;
        File file = isOpen(afd, fileNameWithType);
        if (!file)
        {
            cout<<"没有匹配到相应文件（此文件还未打开，请先打开该文件再写！）"<<endl;
            return;
        }
        cout<<"已匹配到对应文件"<<endl;
        if (!checkWritablePermission(file))
        {
            cout<<"权限不足，该文件不可写！"<<endl;
            return;
        }
        cout<<"请输入要写入的文件内容（按回车确定内容即写入）：";
        string  fileContent;
        getline(cin, fileContent);
        cout<<"保存中，正在尝试写入......"<<endl;
        file->fileSize = fileContent.length();
        file->fileContent->Content = fileContent;
        time(&file->updateTime);
        // 修改文件更新时间
        time(&file->updateTime);
        cout<<"写入" + fileNameWithType + "文件成功！"<<endl;
        return;
    }
}

// 运行
void run (MFD &mfd, AFD &afd, User &currentUser)
{
    string choice1;
    string choice2;
    while (true)
    {
        cout<<"请选择操作：1、创建新用户    2、删除用户    3、显示所有用户    4、登录    5、结束程序"<<endl;
        getline(cin, choice1);
        while (strcmp(choice1.c_str(), "1") != 0 && strcmp(choice1.c_str(), "2") != 0 && strcmp(choice1.c_str(), "3") != 0 && strcmp(choice1.c_str(), "4") != 0 && strcmp(choice1.c_str(), "5") != 0)
        {
            cout<<"非法输入！请重新输入！"<<endl;
            getline(cin, choice1);
        }
        if (strcmp(choice1.c_str(), "1") == 0)
            createUser(mfd);
        else if (strcmp(choice1.c_str(), "2") == 0)
            deleteUser(mfd);
        else if (strcmp(choice1.c_str(), "3") == 0)
            showMFD(mfd);
        else if (strcmp(choice1.c_str(), "4") == 0)
        {
            loginIn(mfd, currentUser);
            while (currentUser)
            {
                cout<<"请选择操作：1、创建新文件    2、删除文件    3、打开文件    4、关闭文件    5、读文件    6、写文件    7、显示所有文件    8、详细显示所有文件信息    9、显示已打开的文件    10、详细显示已打开的文件的信息    11、登出/注销登录"<<endl;
                getline(cin, choice2);
                while (strcmp(choice2.c_str(), "1") != 0 && strcmp(choice2.c_str(), "2") != 0 && strcmp(choice2.c_str(), "3") != 0 && strcmp(choice2.c_str(), "4") != 0 && strcmp(choice2.c_str(), "5") != 0 && strcmp(choice2.c_str(), "6") != 0 && strcmp(choice2.c_str(), "7") != 0 && strcmp(choice2.c_str(), "8") != 0 && strcmp(choice2.c_str(), "9") != 0 && strcmp(choice2.c_str(), "10") != 0 && strcmp(choice2.c_str(), "11") != 0)
                {
                    cout<<"非法输入！请重新输入！"<<endl;
                    getline(cin, choice2);
                }
                if (strcmp(choice2.c_str(), "1") == 0)
                    createFile(currentUser->ufd);
                else if (strcmp(choice2.c_str(), "2") == 0)
                    deleteFile(currentUser->ufd, afd);
                else if (strcmp(choice2.c_str(), "3") == 0)
                    openFile(currentUser->ufd, afd);
                else if (strcmp(choice2.c_str(), "4") == 0)
                    closeFile(currentUser->ufd, afd);
                else if (strcmp(choice2.c_str(), "5") == 0)
                    readFile(currentUser->ufd, afd);
                else if (strcmp(choice2.c_str(), "6") == 0)
                    writeFile(currentUser->ufd, afd);
                else if (strcmp(choice2.c_str(), "7") == 0)
                    showUFD(currentUser->ufd);
                else if (strcmp(choice2.c_str(), "8") == 0)
                    showUFDDetail(currentUser->ufd);
                else if (strcmp(choice2.c_str(), "9") == 0)
                    showAFD(afd);
                else if (strcmp(choice2.c_str(), "10") == 0)
                    showAFDDetail(afd);
                else if (strcmp(choice2.c_str(), "11") == 0)
                    loginOut(afd, currentUser);
                
                cout<<endl;
            }
        }
        else if (strcmp(choice1.c_str(), "5") == 0)
        {
            break;
        }
        cout<<endl;
    }
}

int main()
{
    MFD mfd;
    AFD afd;
    User currentUser;
    init(mfd, afd, currentUser);
    run(mfd, afd, currentUser);
    cout<<"\n文件系统模拟演示结束！"<<endl;
    return 0;
}
```

### 结果展示

1. 用户系统展示（创建用户、删除用户、用户列表）
![](https://s1.vika.cn/space/2023/01/11/af544bdb2378440a9c2954517acaf02c)
2. 登录
    ![](https://s1.vika.cn/space/2023/01/11/6d4b2580847c49b49896915a59056f70)
3. 文件操作
    1. 创建、显示文件信息、显示文件具体信息
	- ![](https://s1.vika.cn/space/2023/01/11/7d6ed4d133ad4c7796ab7f3d3d88aaf9)
    2. 删除文件
	 -    ![](https://s1.vika.cn/space/2023/01/11/4e58b17b6f4644c49f184d305cd1961d)
    3. 打开文件、读写文件
	- ![](https://s1.vika.cn/space/2023/01/11/43aca5735b314978874585335f0f8614)
    4. 用户空间独立性
	- ![](https://s1.vika.cn/space/2023/01/11/8425bacb97ea408dadb32d1044d0130a)

# 实验总结与感想

1. 四次实验分别涵盖了**进程调度**、**存储管理**、**死锁**和**文件系统。**
    1. 进程调度中实现了优先数法和时间片轮转法进行调度进程的模拟
    2. 存储管理中了解了存储管理的两种算法：分区分配算法和请求式分页存储。其中分区分配算法实现了两种：最佳适应和首次适应算法；请求式分页存储分别依靠先进先出原则（FIFO）和最近最久未使用算法（LRU）实现了页面置换。
    3. 死锁中根据现有资源分配和进程情况能够计算出安全运行的进程序列，并且根据银行家算法尽量避免死锁的出现。
    4. 在文件系统中实现了用户系统，在每个用户空间中都有独立的文件目录。也实现了对文件的打开关闭和读写操作。
2. 在实验过程中，对于刚接触计算机时知道的一句话有了更深的感触：**数据结构和算法是一切的基础**。几乎每一个实验都需要很坚实的数据结构基础，这样才能把数据组织成想要的模式。而了解算法后，可以让程序变得高效率并且有效，对于各种情况还能保持不错的鲁棒性。
3. 操作系统是一门复杂、庞大的学科。如果想要真正理解操作系统的全貌还有很长的路要走。而理解数据结构、尝试分析源码都是为理解操作系统行之有效的方法。在今后的学习中我也会继续努力学习操作系统，对计算机体系结构、Linux等知识深入了解学习。