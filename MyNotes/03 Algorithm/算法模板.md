[TOC]

# 基础课

## 一、基础算法

### 快速排序算法模板

模板题 AcWing 785. 快速排序 

```cpp
 void quick_sort(int q[], int l, int r)
 {
     if (l >= r) return;
 
     int i = l - 1, j = r + 1, x = q[l + r >> 1];
     while (i < j)
     {
         do i ++ ; while (q[i] < x);
         do j -- ; while (q[j] > x);
         if (i < j) swap(q[i], q[j]);
     }
     quick_sort(q, l, j), quick_sort(q, j + 1, r);
 }
```

### 归并排序算法模板

模板题 AcWing 787. 归并排序

```cpp
 void merge_sort(int q[], int l, int r)
 {
     if (l >= r) return;
 
     int mid = l + r >> 1;
     merge_sort(q, l, mid);
     merge_sort(q, mid + 1, r);
 
     int k = 0, i = l, j = mid + 1;
     while (i <= mid && j <= r)
         if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
         else tmp[k ++ ] = q[j ++ ];
 
     while (i <= mid) tmp[k ++ ] = q[i ++ ];
     while (j <= r) tmp[k ++ ] = q[j + ];
 
     for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
 }
```

### 二分

### 整数二分算法模板

`l = mid`   `mid = l+r+1>>1`

`l = mid+1`  `mid = l+r>>1`

模板题 AcWing 789. 数的范围

```cpp
 bool check(int x) {/* ... */} // 检查x是否满足某种性质
 
 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
 int bsearch_1(int l, int r)
 {
     while (l < r)
     {
         int mid = l + r >> 1;
         if (check(mid)) r = mid;    // check()判断mid是否满足性质
         else l = mid + 1;
     }
     return l;
 }
 // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
 int bsearch_2(int l, int r)
 {
     while (l < r)
     {
         int mid = l + r + 1 >> 1;
         if (check(mid)) l = mid;
         else r = mid - 1;
     }
     return l;
 }
```

### 浮点数二分算法模板

模板题 AcWing 790. 数的三次方根

```cpp
 bool check(double x) {/* ... */} // 检查x是否满足某种性质
 
 double bsearch_3(double l, double r)
 {
     const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
     while (r - l > eps)
     {
         double mid = (l + r) / 2;
         if (check(mid)) r = mid;
         else l = mid;
     }
     return l;
 }
```

### 高精度

### 高精度加法

模板题 AcWing 791. 高精度加法

- 不圧位代码

```cpp
 using namespace std;
 // C = A + B, A >= 0, B >= 0
 vector<int> add(vector<int> &A, vector<int> &B)
 {
     if (A.size() < B.size()) return add(B, A);
 
     vector<int> C;
     int t = 0;
     for (int i = 0; i < A.size(); i ++ )
     {
         t += A[i];
         if (i < B.size()) t += B[i];
         C.push_back(t % 10);
         t /= 10;
     }
 
     if (t) C.push_back(t);
     return C;
 }
 
 int main()
 {
     string a, b;
     vector<int> A, B;
     cin >> a >> b;
     // 逆序存放, 方便进位
     for (int i = a.size() - 1; i >= 0; i -- ) A.push_back(a[i] - '0');
     for (int i = b.size() - 1; i >= 0; i -- ) B.push_back(b[i] - '0');
 
     auto C = add(A, B);
 
     for (int i = C.size() - 1; i >= 0; i -- ) cout << C[i];
     cout << endl;
 
     return 0;
 }
```

- 压9位的代码

```cpp
 const int base = 1000000000;
 
 vector<int> add(vector<int> &A, vector<int> &B)
 {
     if (A.size() < B.size()) return add(B, A);
 
     vector<int> C;
     int t = 0;
     for (int i = 0; i < A.size(); i ++ )
     {
         t += A[i];
         if (i < B.size()) t += B[i];
         C.push_back(t % base);
         t /= base;
     }
 
     if (t) C.push_back(t);
     return C;
 }
 
 int main()
 {
     string a, b;
     vector<int> A, B;
     cin >> a >> b;
 
     for (int i = a.size() - 1, s = 0, j = 0, t = 1; i >= 0; i -- )
     {
         s += (a[i] - '0') * t;
         j ++, t *= 10;
         if (j == 9 || i == 0)
         {
             A.push_back(s);
             s = j = 0;
             t = 1;
         }
     }
     for (int i = b.size() - 1, s = 0, j = 0, t = 1; i >= 0; i -- )
     {
         s += (b[i] - '0') * t;
         j ++, t *= 10;
         if (j == 9 || i == 0)
         {
             B.push_back(s);
             s = j = 0;
             t = 1;
         }
     }
 
     auto C = add(A, B);
 
     cout << C.back();
     for (int i = C.size() - 2; i >= 0; i -- ) printf("%09d", C[i]);
     cout << endl;
 
     return 0;
 }
```

### 高精度减法

模板题 AcWing 792. 高精度减法

```cpp
 bool cmp(vector<int> &A, vector<int> &B)
 {
     if (A.size() != B.size()) return A.size() > B.size();
 
     for (int i = A.size() - 1; i >= 0; i -- )
         if (A[i] != B[i])
             return A[i] > B[i];
 
     return true;
 }
 // C = A - B, 满足A >= B, A >= 0, B >= 0
 vector<int> sub(vector<int> &A, vector<int> &B)
 {
     vector<int> C;
     for (int i = 0, t = 0; i < A.size(); i ++ )
     {
         t = A[i] - t;
         if (i < B.size()) t -= B[i];
         C.push_back((t + 10) % 10);
         if (t < 0) t = 1;
         else t = 0;
     }
 
     while (C.size() > 1 && C.back() == 0) C.pop_back();
     return C;
 }
 
 int main()
 {
     string a, b;
     vector<int> A, B;
     cin >> a >> b;
     for (int i = a.size() - 1; i >= 0; i -- ) A.push_back(a[i] - '0');
     for (int i = b.size() - 1; i >= 0; i -- ) B.push_back(b[i] - '0');
 
     vector<int> C;
 
     if (cmp(A, B)) C = sub(A, B);
     else C = sub(B, A), cout << '-';
 
     for (int i = C.size() - 1; i >= 0; i -- ) cout << C[i];
     cout << endl;
 
     return 0;
 }
```

### 高精度乘低精度

模板题 AcWing 793. 高精度乘法

```cpp
 // 
C = A * b, A >= 0, b >= 0
 vector<int> mul(vector<int> &A, int b)
 {
     vector<int> C;
     int t = 0;
     for (int i = 0; i < A.size() || t; i ++ )
     {
         if (i < A.size()) t += A[i] * b;
         C.push_back(t % 10);
         t /= 10;
     }
     while (C.size() > 1 && C.back() == 0) C.pop_back();
     return C;
 }
 
 
 int main()
 {
     string a;
     int b;
     cin >> a >> b;

     vector<int> A;
     for (int i = a.size() - 1; i >= 0; i -- ) A.push_back(a[i] - '0');
 
     auto C = mul(A, b);
 
     for (int i = C.size() - 1; i >= 0; i -- ) printf("%d", C[i]);
 
     return 0;
 }
```

### 高精度除以低精度

模板题 AcWing 794. 高精度除法

```cpp
// A / b = C ... r, A >= 0, b > 0
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}

int main()
{
    string a;
    vector<int> A;

    int B;
    cin >> a >> B;
    for (int i = a.size() - 1; i >= 0; i -- ) A.push_back(a[i] - '0');

    int r;
    auto C = div(A, B, r);

    for (int i = C.size() - 1; i >= 0; i -- ) cout << C[i];

    cout << endl << r << endl;

    return 0;
}
```

### 前缀和与差分

**前缀和覆盖前面** **差分影响后面**

### 一维前缀和

模板题 AcWing 795. 前缀和

```cpp
S[i] = a[1] + a[2] + ... + a[i];
a[l] + ... + a[r] = S[r] - S[l - 1];
//构造
for (int i = 1; i <= n; i ++ )
{
    cin>>a[i];
    s[i] = a[i]+s[i-1];
}
//查询[l,r]的和
s[r] - s[l-1]
```

### 二维前缀和

模板题 AcWing 796. 子矩阵的和

```cpp
S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]

//构造
for(int i=1; i<=n; i++) {
    for(int j=1; j<=m; j++) {
        cin >> g[i][j];
        s[i][j] = g[i][j] + s[i][j-1] + s[i-1][j] - s[i-1][j-1];
    }
}
//查询
int x1,y1,x2,y2;
cin >> x1 >> y1 >> x2 >> y2;
cout << s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1] << endl;
```

### 一维差分

模板题 AcWing 797. 差分

```
//构造差分
for (int i = 1; i <= n; i ++ ) {
    cin >> a[i];
    d[i] = a[i] - a[i-1];
}

//给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
d[l] += c;
d[r+1] -= c;

//结果
for (int i = 1; i <= n; i ++ ) {
    s[i] = d[i]+s[i-1];
    cout << s[i] << ' ';
}
```

### 二维差分

模板题 AcWing 798. 差分矩阵

```
//给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
void insert(int x1, int y1, int x2, int y2, int c)
{
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
```

### 位运算

模板题 AcWing 801. 二进制中1的个数

```
求n的第k位数字: n >> k & 1
返回n的最后一位1：lowbit(n) = n & -n
```

### 双指针算法

模板题 AcWIng 799. 最长连续不重复子序列, AcWing 800. 数组元素的目标和

```
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;

    // 具体问题的逻辑
}
```

<font color='blue'>

常见问题分类: 
(1) 对于一个序列，用两个指针维护一段区间 
(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作

</font>

### 离散化

模板题 AcWing 802. 区间和

```
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
```

### 区间合并

模板题 AcWing 803. 区间合并

```
// 将所有存在交集的区间合并
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}
```

## 二、数据结构

### 单链表

模板题 AcWing 826. 单链表

```cpp
// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}

// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}
```

### 双链表

模板题 AcWing 827. 双链表
```cpp
// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

// 初始化
void init()
{
    //0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在节点a的右边插入一个数x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// 删除节点a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```

### 栈

模板题 AcWing 828. 模拟栈
```cpp
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt > 0)
{

}
```

### 队列

模板题 AcWing 829. 模拟队列
```cpp
1. 普通队列：
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh <= tt)
{

}

2. 循环队列
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt)
{

}
```

### 单调栈

模板题 AcWing 830. 单调栈
常见模型：找出每个数左边离它最近的比它大/小的数

```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```

### 单调队列

模板题 AcWing 154. 滑动窗口
常见模型：找出滑动窗口中的最大值/最小值

```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```

### KMP

模板题 AcWing 831. KMP字符串

```
// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
求模式串的Next数组：
for (int i = 2, j = 0; i <= m; i ++ )
{
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

// 匹配
for (int i = 1, j = 0; i <= n; i ++ )
{
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == m)
    {
        j = ne[j];
        // 匹配成功后的逻辑
    }
}
```

### Trie树

模板题 AcWing 835. Trie字符串统计

```
int son[N][26], cnt[N], idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量

// 插入一个字符串
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}

// 查询字符串出现的次数
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```

### 并查集

模板题 AcWing 836. 合并集合, AcWing 837. 连通块中点的数量

```
(1)朴素并查集：

    int p[N]; //存储每个点的祖宗节点

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);

(2)维护size的并查集：

    int p[N], size[N];
    //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }

    // 合并a和b所在的两个集合：
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);

(3)维护到祖宗节点距离的并查集：

    int p[N], d[N];
    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
```

### 堆

模板题 AcWing 838. 堆排序, AcWing 839. 模拟堆

```
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置
// hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;
    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}

void up(int u)
{
    while (u / 2 && h[u] < h[u / 2])
    {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}

// O(n)建堆
for (int i = n / 2; i; i -- ) down(i);
```

### 哈希

### 一般哈希

模板题 AcWing 840. 模拟散列表

```
(1) 拉链法
    int h[N], e[N], ne[N], idx;

    // 向哈希表中插入一个数
    void insert(int x)
    {
        int k = (x % N + N) % N;
        e[idx] = x;
        ne[idx] = h[k];
        h[k] = idx ++ ;
    }

    // 在哈希表中查询某个数是否存在
    bool find(int x)
    {
        int k = (x % N + N) % N;
        for (int i = h[k]; i != -1; i = ne[i])
            if (e[i] == x)
                return true;

        return false;
    }

(2) 开放寻址法
    int h[N];

    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
    int find(int x)
    {
        int t = (x % N + N) % N;
        while (h[t] != null && h[t] != x)
        {
            t ++ ;
            if (t == N) t = 0;
        }
        return t;
    }
```

### 字符串哈希

模板题 AcWing 841. 字符串哈希

<font color='blue'>

核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低

小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果

</font>

```
typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

// 初始化
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```

### C++ STL简介

```
vector, 变长数组，倍增的思想
    size()  返回元素个数
    empty()  返回是否为空
    clear()  清空
    front()/back()
    push_back()/pop_back()
    begin()/end()
    []
    支持比较运算，按字典序

pair<int, int>
    first, 第一个元素
    second, 第二个元素
    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）

string，字符串
    size()/length()  返回字符串长度
    empty()
    clear()
    substr(起始下标，(子串长度))  返回子串
    c_str()  返回字符串所在字符数组的起始地址

queue, 队列
    size()
    empty()
    push()  向队尾插入一个元素
    front()  返回队头元素
    back()  返回队尾元素
    pop()  弹出队头元素

priority_queue, 优先队列，默认是大根堆
    size()
    empty()
    push()  插入一个元素
    top()  返回堆顶元素
    pop()  弹出堆顶元素
    定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;

stack, 栈
    size()
    empty()
    push()  向栈顶插入一个元素
    top()  返回栈顶元素
    pop()  弹出栈顶元素

deque, 双端队列
    size()
    empty()
    clear()
    front()/back()
    push_back()/pop_back()
    push_front()/pop_front()
    begin()/end()
    []

set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列
    size()
    empty()
    clear()
    begin()/end()
    ++, -- 返回前驱和后继，时间复杂度 O(logn)

    set/multiset
        insert()  插入一个数
        find()  查找一个数
        count()  返回某一个数的个数
        erase()
            (1) 输入是一个数x，删除所有x   O(k + logn)
            (2) 输入一个迭代器，删除这个迭代器
        lower_bound()/upper_bound()
            lower_bound(x)  返回大于等于x的最小的数的迭代器
            upper_bound(x)  返回大于x的最小的数的迭代器
    map/multimap
        insert()  插入的数是一个pair
        erase()  输入的参数是pair或者迭代器
        find()
        []  注意multimap不支持此操作。 时间复杂度是 O(logn)
        lower_bound()/upper_bound()

unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
    和上面类似，增删改查的时间复杂度是 O(1)
    不支持 lower_bound()/upper_bound()， 迭代器的++，--

bitset, 圧位
    bitset<10000> s;
    ~, &, |, ^
    >>, <<
    ==, !=
    []

    count()  返回有多少个1

    any()  判断是否至少有一个1
    none()  判断是否全为0

    set()  把所有位置成1
    set(k, v)  将第k位变成v
    reset()  把所有位变成0
    flip()  等价于~
    flip(k) 把第k位取反
```

## 三、搜索与图论

### 树与图的存储

树是一种特殊的图，与图的存储方式相同。
对于无向图中的边ab，存储两条有向边a->b, b->a。
因此我们可以只考虑有向图的存储。

(1) 邻接矩阵：`g[a][b] 存储边a->b`

(2) 邻接表：

```
// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[N], ne[N], idx;

// 添加一条边a->b
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// 初始化
idx = 0;
memset(h, -1, sizeof h);
```

### 树与图的遍历

时间复杂度 **O(n+m)**, **n** 表示点数，**m** 表示边数

### (1) 深度优先遍历

模板题 AcWing 846. 树的重心

```
int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}
```

### (2) 宽度优先遍历

模板题 AcWing 847. 图中点的层次

```
queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
```

### 拓扑排序

模板题 AcWing 848. 有向图的拓扑序列
时间复杂度 **O(n+m)**,  **n**表示点数，**m** 表示边数

```
bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 存储点i的入度
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}
```

### 最短路

### 朴素dijkstra算法

模板题 AcWing 849. Dijkstra求最短路 I
时间复杂是 **O(n2+m)**, **n** 表示点数，**m** 表示边数

```
int g[N][N];  // 存储每条边
int dist[N];  // 存储1号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        // 用t更新其他点的距离
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);

        st[t] = true;
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

### 堆优化版dijkstra

模板题 AcWing 850. Dijkstra求最短路 II
时间复杂度 **O(mlogn)**, **n** 表示点数，**m** 表示边数

```cpp
typedef pair<int, int> PII;

int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});      // first存储距离，second存储节点编号

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

### Bellman-Ford算法

模板题 AcWing 853. 有边数限制的最短路
时间复杂度 **O(nm)**, **n** 表示点数，**m** 表示边数
注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。

```
int n, m;       // n表示点数，m表示边数
int dist[N];        // dist[x]存储1到x的最短路距离

struct Edge     // 边，a表示出点，b表示入点，w表示边的权重
{
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > dist[a] + w)
                dist[b] = dist[a] + w;
        }
    }

    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}
```

### spfa 算法（队列优化的Bellman-Ford算法）

模板题 AcWing 851. spfa求最短路
时间复杂度 平均情况下 **O(m)**，最坏情况下 **O(nm)**, **n** 表示点数，**m** 表示边数

```
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

### spfa判断图中是否存在负环

模板题 AcWing 852. spfa判断负环
时间复杂度是 **O(nm)**, **n** 表示点数，**m** 表示边数

```
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数
bool st[N];     // 存储每个点是否在队列中

// 如果存在负环，则返回true，否则返回false。
bool spfa()
{
    // 不需要初始化dist数组
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。

    queue<int> q;
    for (int i = 1; i <= n; i ++ )
    {
        q.push(i);
        st[i] = true;
    }

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return false;
}
```

### floyd算法

模板题 AcWing 854. Floyd求最短路
时间复杂度是 **O(n3)**, **n** 表示点数

```
初始化：
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```

### 最小生成树

### 朴素版prim算法

模板题 AcWing 858. Prim算法求最小生成树
时间复杂度是 **O(n2+m)**, **n** 表示点数，**m** 表示边数

```cpp
int n;      // n表示点数
int g[N][N];        // 邻接矩阵，存储所有边
int dist[N];        // 存储其他点到当前最小生成树的距离
bool st[N];     // 存储每个点是否已经在生成树中

// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
int prim()
{
    memset(dist, 0x3f, sizeof dist);

    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        if (i && dist[t] == INF) return INF;

        if (i) res += dist[t];
        st[t] = true;

        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }

    return res;
}
```

### Kruskal算法

模板题 AcWing 859. Kruskal算法求最小生成树
时间复杂度是 **O(mlogm)**, **n** 表示点数，**m** 表示边数

```cpp
int n, m;       // n是点数，m是边数
int p[N];       // 并查集的父节点数组

struct Edge     // 存储边
{
    int a, b, w;

    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];

int find(int x)     // 并查集核心操作
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m);

    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集

    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }

    if (cnt < n - 1) return INF;
    return res;
}
```

### 二分图

### 染色法判别二分图

模板题 AcWing 860. 染色法判定二分图
时间复杂度是 **O(n+m)**, **n** 表示点数，**m** 表示边数

```cpp
int n;      // n表示点数
int h[N], e[M], ne[M], idx;     // 邻接表存储图
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色

// 参数：u表示当前节点，c表示当前点的颜色
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```

### 匈牙利算法

模板题 AcWing 861. 二分图的最大匹配
时间复杂度是 **O(nm)**, **n** 表示点数，**m** 表示边数

```cpp
int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```

## 四、数学知识

### 质数

### 试除法判定质数

模板题 AcWing 866. 试除法判定质数

```cpp
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```

### 试除法分解质因数

模板题 AcWing 867. 分解质因数

```cpp
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```

### 朴素筛法求素数

模板题 AcWing 868. 筛质数

```cpp
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```

### 线性筛法求素数

模板题 AcWing 868. 筛质数

```cpp
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```

### 约数

### 试除法求所有约数

模板题 AcWing 869. 试除法求约数

```cpp
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```

### 约数个数和约数之和

模板题 AcWing 870. 约数个数, AcWing 871. 约数之和

```cpp
如果 N = p1^c1 * p2^c2 * ... *pk^ck
约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)
约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)
```

### 欧几里得算法

模板题 AcWing 872. 最大公约数

```cpp
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```

### 欧拉函数

### 求欧拉函数

模板题 AcWing 873. 欧拉函数

```cpp
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);

    return res;
}
```

### 筛法求欧拉函数

模板题 AcWing 874. 筛法求欧拉函数

```cpp
int primes[N], cnt;     // primes[]存储所有素数
int euler[N];           // 存储每个数的欧拉函数
bool st[N];         // st[x]存储x是否被筛掉

void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```

### 快速幂

模板题 AcWing 875. 快速幂

```cpp
求 m^k mod p，时间复杂度 O(logk)。

int qmi(int m, int k, int p)
{
    int res = 1 % p, t = m;
    while (k)
    {
        if (k&1) res = res * t % p;
        t = t * t % p;
        k >>= 1;
    }
    return res;
}
```

### 扩展欧几里得算法

模板题 AcWing 877. 扩展欧几里得算法

```cpp
// 求x, y，使得ax + by = gcd(a, b)
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```

### 高斯消元

模板题 AcWing 883. 高斯消元解线性方程组

```cpp
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ )   // 找到绝对值最大的行
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;

        if (fabs(a[t][c]) < eps) continue;

        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);      // 将绝对值最大的行换到最顶端
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];      // 将当前行的首位变成1
        for (int i = r + 1; i < n; i ++ )       // 用当前行将下面所有的列消成0
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];

        r ++ ;
    }

    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; // 无解
        return 1; // 有无穷多组解
    }

    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];

    return 0; // 有唯一解
}
```

### 组合数

### 递归法求组合数

模板题 AcWing 885. 求组合数 I

```cpp
// c[a][b] 表示从a个苹果中选b个的方案数
for (int i = 0; i < N; i ++ )
    for (int j = 0; j <= i; j ++ )
        if (!j) c[i][j] = 1;
        else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
```

### 通过预处理逆元的方式求组合数

模板题 AcWing 886. 求组合数 II

```cpp
首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]
如果取模的数是质数，可以用费马小定理求逆元
int qmi(int a, int k, int p)    // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

// 预处理阶乘的余数和阶乘逆元的余数
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```

### Lucas定理

模板题 AcWing 887. 求组合数 III

```cpp
若p是质数，则对于任意整数 1 <= m <= n，有：
    C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)

int qmi(int a, int k, int p)  // 快速幂模板
{
    int res = 1 % p;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int C(int a, int b, int p)  // 通过定理求组合数C(a, b)
{
    if (a < b) return 0;

    LL x = 1, y = 1;  // x是分子，y是分母
    for (int i = a, j = 1; j <= b; i --, j ++ )
    {
        x = (LL)x * i % p;
        y = (LL) y * j % p;
    }

    return x * (LL)qmi(y, p - 2, p) % p;
}

int lucas(LL a, LL b, int p)
{
    if (a < p && b < p) return C(a, b, p);
    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}
```

### 分解质因数法求组合数

模板题 AcWing 888. 求组合数 IV

```cpp
当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：
    1. 筛法求出范围内的所有质数
    2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...
    3. 用高精度乘法将所有质因子相乘

int primes[N], cnt;     // 存储所有质数
int sum[N];     // 存储每个质数的次数
bool st[N];     // 存储每个数是否已被筛掉

void get_primes(int n)      // 线性筛法求素数
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

int get(int n, int p)       // 求n！中的次数
{
    int res = 0;
    while (n)
    {
        res += n / p;
        n /= p;
    }
    return res;
}

vector<int> mul(vector<int> a, int b)       // 高精度乘低精度模板
{
    vector<int> c;
    int t = 0;
    for (int i = 0; i < a.size(); i ++ )
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }

    while (t)
    {
        c.push_back(t % 10);
        t /= 10;
    }

    return c;
}

get_primes(a);  // 预处理范围内的所有质数

for (int i = 0; i < cnt; i ++ )     // 求每个质因数的次数
{
    int p = primes[i];
    sum[i] = get(a, p) - get(b, p) - get(a - b, p);
}

vector<int> res;
res.push_back(1);

for (int i = 0; i < cnt; i ++ )     // 用高精度乘法将所有质因子相乘
    for (int j = 0; j < sum[i]; j ++ )
        res = mul(res, primes[i]);

```

### 卡特兰数

模板题 AcWing 889. 满足条件的01序列

给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)

### 博弈论

### NIM游戏

模板题 AcWing 891. Nim游戏
给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。

我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。
所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。
NIM博弈不存在平局，只有先手必胜和先手必败两种情况。

**定理**： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0

### 公平组合游戏ICG

若一个游戏满足：

由两名玩家交替行动；
在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；
不能行动的玩家判负；
则称该游戏为一个公平组合游戏。
NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。

### 有向图游戏

给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。
任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。

### Mex运算

设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：
mex(S) = min{x}, x属于自然数，且x不属于S

### SG函数

在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：
SG(x) = mex({SG(y1), SG(y2), …, SG(yk)})
特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。

### 有向图游戏的和 —— 模板题 AcWing 893. 集合-Nim游戏

设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。
有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：
SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)

**定理**
有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。
有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。







# 提高课

## 数据结构

### 树状数组

**242.一个简单的整数问题**

- `C l r d`，表示把数列中第 $l∼r$ 个数都加 $d$。
- `Q x`，表示询问数列中第 $x$ 个数的值。

树状数组维护差分
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010;
typedef long long LL;

int n, m;
int tr[N];
int a[N];

int lowbit(int x)
{
    return x & -x;
}

void add(int x, int c)
{
    for (int i = x; i <= n; i += lowbit(i)) tr[i] += c;
}

LL sum(int k)
{
    int res = 0;
    for (int i = k; i; i -= lowbit(i)) res += tr[i];
    return res;
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++) cin >> a[i];

    for (int i = 1; i <= n; i ++)
    {
        add(i, a[i] - a[i - 1]);        // 差分数组套树状数组
    }

    for (int i = 1; i <= m; i ++)
    {
        char op[2];
        int l, r, d, x;
        scanf("%s", op);
        if (*op == 'C')         // +
        {
            cin >> l >> r >> d;
            add(l, d);
            add(r + 1, -d);
        }
        else                    // 查
        {
            cin >> x;
            cout << sum(x) << endl;
        }
    }
}
```


合适数对【树状数组 + 前缀和】
```CPP
#include <bits/stdc++.h>
#define LL long long
using namespace std;

const int N = 2e5 + 10;

LL a[N];
vector<LL> num;

int get(LL x){
    return lower_bound(num.begin(), num.end(), x) - num.begin() + 1;
}

int tr[N];
int lowbit(int x){return x & -x;}
void add(int u){
    while(u < N){
        tr[u] += 1;
        u += lowbit(u);
    }
}

int query(int u){
    int res = 0;
    while(u){
        res += tr[u];
        u -= lowbit(u);
    }
    return res;
}

int main(){
    int n;
    LL t;
    cin >> n >> t;
    for(int i = 1; i <= n; i++) cin >> a[i], a[i] += a[i-1], num.push_back(a[i]);
    num.push_back(0);
    sort(num.begin(), num.end());
    num.erase(unique(num.begin(), num.end()), num.end());
    add(get(0));
    int cnt = 1;
    LL ans = 0;
    for(int i = 1; i <= n; i++){
        int u = get(a[i] - t + 1);
        ans += cnt - query(u - 1);
        add(get(a[i]));
        cnt++;
    }
    cout << ans;
    return 0;
}
```

### 线段树

操作 1：`1 t g c`，表示把所有满足` t≤i≤g` 的 `ai` 改为 `ai×c`；
操作 2：`2 t g c`，表示把所有满足 `t≤i≤g` 的 `ai` 改为 `ai+c`；
操作 3：`3 t g`，询问所有满足 `t≤i≤g` 的 `ai` 的和模 `P` 的值
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010;

int n, p, m;
int w[N];
struct Node
{
    int l, r;
    int sum, add, mul;
}tr[N * 4];

void pushup(int u)
{
    tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % p;
}

void eval(Node &t, int add, int mul)
{
    t.sum = ((LL)t.sum * mul + (LL)(t.r - t.l + 1) * add) % p;
    t.mul = (LL)t.mul * mul % p;
    t.add = ((LL)t.add * mul + add) % p;
}

void pushdown(int u)
{
    eval(tr[u << 1], tr[u].add, tr[u].mul);
    eval(tr[u << 1 | 1], tr[u].add, tr[u].mul);
    tr[u].add = 0, tr[u].mul = 1;
}

void build(int u, int l, int r)
{
    if (l == r) tr[u] = {l, r, w[r], 0, 1};
    else
    {
        tr[u] = {l, r, 0, 0, 1};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}

void modify(int u, int l, int r, int add, int mul)
{
    if (tr[u].l >= l && tr[u].r <= r) eval(tr[u], add, mul);
    else
    {
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) modify(u << 1, l, r, add, mul);
        if (r > mid) modify(u << 1 | 1, l, r, add, mul);
        pushup(u);
    }
}

int query(int u, int l, int r)
{
    if (tr[u].l >= l && tr[u].r <= r) return tr[u].sum;

    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    int sum = 0;
    if (l <= mid) sum = query(u << 1, l, r);
    if (r > mid) sum = (sum + query(u << 1 | 1, l, r)) % p;
    return sum;
}

int main()
{
    scanf("%d%d", &n, &p);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);
    build(1, 1, n);

    scanf("%d", &m);
    while (m -- )
    {
        int t, l, r, d;
        scanf("%d%d%d", &t, &l, &r);
        if (t == 1)
        {
            scanf("%d", &d);
            modify(1, l, r, 0, d);
        }
        else if (t == 2)
        {
            scanf("%d", &d);
            modify(1, l, r, d, 1);
        }
        else printf("%d\n", query(1, l, r));
    }

    return 0;
}
```



# 例题

收集卡牌【数学期望/dp/记忆化搜索】
```CPP
#include <bits/stdc++.h>
using namespace std;

int n, k;
double a[20];
double f[81][1 << 16];

double dp(int depth, int coin, int state, int cnt){
    if(f[coin][state]) return f[coin][state];      //标准的记搜板子
    if(cnt * k <= coin) return depth;       //判断是否是叶子节点
    double s = 0;
    for(int i = 0; i < n; i ++ ){    //枚举抽哪张卡
        if((state >> i) & 1)      //如果已经有这张卡了, 就让硬币数+1
            s += a[i] * dp(depth + 1, coin + 1, state, cnt);
        else
            s += a[i] * dp(depth + 1, coin, state | (1 << i), cnt - 1);   //如果没有这张卡, 就让状态更新
    }
    return f[coin][state] = s;
}

int main()
{
    cin >> n >> k;
    for(int i = 0; i < n; i ++ )
        cin >> a[i];

    cout << dp(0, 0, 0, n);

    return 0;
}
```

校门外的树【DP/约数】
```CPP
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1010, M = 100010, mod = 1e9 + 7;
typedef long long LL;

int n;
int a[N];
int f[N]; // a0 - ai的所有选法的集合

vector<int> q[M]; // i 的约数
bool st[M]; 


int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++) cin >> a[i]; // 0 - n-1

    // 预处理约数
    for (int i = 1; i < M; i ++)
        for (int j = i * 2; j < M; j += i)
            q[j].push_back(i);

    f[0] = 1; // 只有一个原点，1种方案
    for (int i = 1; i < n; i ++)
    {
        memset(st, 0, sizeof st); // 记录用过的约数，避免重复 
        for (int j = i - 1; j >= 0; j --) // ai 的上一个点。从后向前枚举，判断哪一个数被用过
        {
            int d = a[i] - a[j], cnt = 0;
            for (int k : q[d])
                if (!st[k]) 
                {
                    cnt ++;
                    st[k] = true;
                }
            st[d] = true; // 记录约数的时候没有记录自身。此时要排除。避免算进去障碍物
            f[i] = (f[i] + (LL)f[j] * cnt) % mod;
        }
    }
    cout << f[n - 1];

    return 0;
}
```

食材运输【贪心/dfs/状压dp/二分】
```CPP
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;
#define x first
#define y second

const int N = 110, M = N * 2, S = 1 << 12;
int h[N], e[M], w[M], ne[M], idx;
int d[N][12];
int f[S], state[N];

void add(int a, int b, int c)  // 添加一条边a->b，边权为c
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int n, m, k;
int need[N][12]; // 第i个节点是否需要第j种食材

PII dfs(int u, int fa, int v)   // 返回 <从起点经过所有需要第v种食材的节点有返回起点的距离，起点到最远一个节点的距离>
{
    PII ans(0, -1);                 // 初始化：距离是0，此节点包括下属节点没有需要食材的点
    if (need[u][v] == 1) ans.y = 0; // 表示此节点需要食材，并且到需要食材节点的距离是0（就是本身）

    for (int i = h[u]; i != -1; i = ne[i])  // 枚举所有相邻点
    {
        int j = e[i];
        if (j == fa) continue;

        auto t = dfs(j, u, v);
        if (t.y != -1)          // 如果下面有需要食材的点
        {
            ans.x += w[i] * 2 + t.x;    // 更新总距离
            ans.y = max(ans.y, w[i] + t.y); // 比较最远距离
        }
    }

    return ans;

}

bool judge(int mid)
{
    // 建表：在 mid 内起点与食材的满足情况
    memset(state, 0, sizeof state);
    for (int i = 1; i <= n; i ++)
        for (int j = 0; j < k; j ++)
            if (d[i][j] <= mid)
                state[i] |= (1 << j);

    memset(f, 0x3f, sizeof f);  // 求最小值，初始化最大
    f[0] = 0;

    for (int i = 0; i < (1 << k); i ++)
        for (int j = 1; j <= n; j ++)
            f[i | state[j]] = min(f[i | state[j]], f[i] + 1);   // 状态 i 加上第 j 行的状态，最少需要几行

    return f[(1 << k) - 1] <= m;    // 判断最终选取边数是否不超过 m  

}


int main()
{
    cin >> n >> m >> k;

    for (int i = 1; i <= n ; i ++)
        for (int j = 0; j < k; j ++)
            cin >> need[i][j];

    // 建树
    memset(h, -1, sizeof h);
    for (int i = 1; i < n; i ++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c); add(b, a, c);
    }

    // 预处理
    for (int i = 1; i <= n; i ++ )
        for (int j = 0; j < k; j ++ )
        {
            auto t = dfs(i, -1, j);  // 第i个节点作为起点，父节点是-1，考虑第j种食材
            if (t.y != -1) d[i][j] = t.x - t.y;
        }

    int l = 0, r = 2e9; // 一条边最长1e6，最多100点，总路径最长1e8，两倍最长2e8
    while (l < r)
    {
        int mid = l + r >> 1;
        if (judge(mid)) r = mid;    // 满足就试试能不能更小
        else l = mid + 1;
    }

    printf("%d", r);
}
```

网络延时【dfs/树形dp/树的直径】
```CPP
#include <iostream>
#include <cstring>

using namespace std;

const int N = 100010;

int e[N] , ne[N] , h[N] , idx;
int f[N];//f[u]表示u到最远叶节点的距离。显然如果u是节点，则f[u]=0。
int n , m , ans;

void add(int a , int b)
{
    e[idx] = b , ne[idx] = h[a] , h[a] = idx++;
}

void dfs(int u)//求以u为根节点到叶节点的最大距离
{
    int a = 0 , b = 0;//a记录u到最远叶节点的距离，b记录u到次远叶节点的距离
    for(int i = h[u] ; ~i ; i = ne[i])
    {
        int j = e[i];
        //求子节点j到最远叶节点的距离
        dfs(j);

        int t = f[j] + 1;//u通过j能到的最远叶节点的距离

        //更新a、b
        if(t >= a)
            b = a , a = t;
        else if(t > b)
            b = t;
    }

    f[u] = a;
    //最后的答案就是u所能到的最远叶节点距离和次远叶节点距离之和
    ans = max(ans , a + b);
}

int main()
{
    cin >> n >> m;

    memset(h , -1 , sizeof h);
    //电脑其实和交换机等价，所以电脑的标号从n继续往后标记即可
    for(int i = 2 ; i <= n + m ; i++)
    {
        int j;
        cin >> j;
        add(j , i);//因为是自根向下DP，所以建一条边即可。
    }

    dfs(1);

    cout << ans << endl;
}
```


星际旅行【线段树/懒标记/离散化】
-   动力增加：指定一个区间 [L,R][L,R] 和三个参数 a,b,c 令区间内所有动力装置的 3 维坐标分别增加 a,b,c
-   动力强化：指定一个区间 [L,R][L,R] 和一个参数 k，令区间内所有动力装置的 3 维坐标分别乘 k
-   动力转向：指定一个区间 [L,R][L,R] ，令区间内所有动力装置的 x,y,zx,y,z 坐标分别变为原来的 y 坐标，z 坐标，x 坐标
-   动力查询：指定一个区间 [L,R][L,R] ，询问如果使用区间内所有动力装置各一次能将乔帝送到离起点多远的地方(输出距离的平方除以 1E9+7 的余数)
```CPP
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

typedef long long LL;
const int N = 80010, MOD = 1e9 + 7;

int n, m;
struct Q
{
    int t, l, r, k, a, b, c;
}q[N];
vector<int> xs;
struct Node
{
    int l, r, k;
    int a[3], b[3], s[3];

    int get_len()
    {
        return xs[r] - xs[l - 1];
    }
}tr[N * 4];

int get(int x)
{
    return lower_bound(xs.begin(), xs.end(), x) - xs.begin();
}

void pushup(int u)
{
    auto l = tr[u << 1].s, r = tr[u << 1 | 1].s;
    for (int i = 0; i < 3; i ++ )
        tr[u].s[i] = (l[i] + r[i]) % MOD;
}

void rotate(int a[])
{
    int t = a[0];
    a[0] = a[1], a[1] = a[2], a[2] = t;
}

void eval(int u, int k)
{
    k %= 3;
    for (int i = 0; i < k; i ++ )
    {
        rotate(tr[u].a), rotate(tr[u].b), rotate(tr[u].s);
    }
    tr[u].k += k;
}

void eval(int u, int a[], int b[])
{
    for (int i = 0; i < 3; i ++ )
    {
        tr[u].s[i] = ((LL)tr[u].s[i] * a[i] + (LL)tr[u].get_len() * b[i]) % MOD;
        int c = (LL)tr[u].a[i] * a[i] % MOD;
        int d = ((LL)tr[u].b[i] * a[i] + b[i]) % MOD;
        tr[u].a[i] = c, tr[u].b[i] = d;
    }
}

void pushdown(int u)
{
    eval(u << 1, tr[u].k), eval(u << 1 | 1, tr[u].k);
    tr[u].k = 0;

    eval(u << 1, tr[u].a, tr[u].b), eval(u << 1 | 1, tr[u].a, tr[u].b);
    for (int i = 0; i < 3; i ++ )
        tr[u].a[i] = 1, tr[u].b[i] = 0;
}

void build(int u, int l, int r)
{
    tr[u] = {l, r};
    for (int i = 0; i < 3; i ++ ) tr[i].a[i] = 1;
    if (l == r) return;
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
}

void update(int u, int l, int r, int k, int a[], int b[])
{
    if (tr[u].l >= l && tr[u].r <= r) eval(u, k), eval(u, a, b);
    else
    {
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) update(u << 1, l, r, k, a, b);
        if (r > mid) update(u << 1 | 1, l, r, k, a, b);
        pushup(u);
    }
}

vector<int> query(int u, int l, int r)
{
    if (tr[u].l >= l && tr[u].r <= r) return {tr[u].s[0], tr[u].s[1], tr[u].s[2]};
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    vector<int> res(3);
    if (l <= mid) res = query(u << 1, l, r);
    if (r > mid)
    {
        auto t = query(u << 1 | 1, l, r);
        for (int i = 0; i < 3; i ++ )
            res[i] = (res[i] + t[i]) % MOD;
    }
    return res;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < m; i ++ )
    {
        q[i].k = 1;
        scanf("%d%d%d", &q[i].t, &q[i].l, &q[i].r);
        if (q[i].t == 1) scanf("%d%d%d", &q[i].a, &q[i].b, &q[i].c);
        else if (q[i].t == 2) scanf("%d", &q[i].k);
        xs.push_back(q[i].l - 1), xs.push_back(q[i].r);
    }
    sort(xs.begin(), xs.end());
    xs.erase(unique(xs.begin(), xs.end()), xs.end());

    build(1, 0, xs.size() - 1);
    for (int i = 0; i < m; i ++ )
    {
        int t = q[i].t, l = get(q[i].l - 1) + 1, r = get(q[i].r);
        int a[] = {q[i].k, q[i].k, q[i].k}, b[] = {q[i].a, q[i].b, q[i].c};
        if (t == 1 || t == 2)
            update(1, l, r, 0, a, b);
        else if (t == 3)
            update(1, l, r, 1, a, b);
        else
        {
            auto t = query(1, l, r);
            LL sum = 0;
            for (int j = 0; j < 3; j ++ )
                sum += (LL)t[j] * t[j];
            printf("%lld\n", sum % MOD);
        }
    }
    return 0;
}
```


**2014. 岛**
题意：
一列高度不同的山，海平面会处在不同高度。求某个时刻岛屿最多的数目
$H_i <= 10^9, N <= 10^5$   所以需要离散化

思路：
枚举海平面高度，从高到低。高度使用贡献法，遍历一遍确定不同高度的贡献。
```CPP
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;

const int N = 100010, M = 10010;

int n;
int a[N], b[N]; 

unordered_map<int,int> id;
unordered_map<int,int> cnt;

void lisan()
{
    for (int i = 1; i <= n; i ++) b[i] = a[i];
    
    sort(b + 1, b + 1 + n);
    int m = unique(b + 1, b + 1 + n) - b - 1;
    
    // for (int i = 0; i <= m; i ++)
    //     printf("%d ", b[i]);
    // puts("");
    
    for (int i = 0; i <= m; i ++) id[b[i]] = i;
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++)
    {
        cin >> a[i];
        if (a[i] == a[i - 1]) i--, n--;
    }

    a[0] = a[n + 1] = 0;
    
    lisan();
    
    for (int i = 1; i <= n; i ++)
    {
        int x = id[a[i - 1]], y = id[a[i]], z = id[a[i + 1]];
        if (x < y && y > z) cnt[y] ++;
        else if (x > y && y < z) cnt[y] --;
    }

    int ans = 0, sum = 0;
    for (int i = N; i; i --)
    {
        sum += cnt[i];
        ans = max(ans, sum);
    }
    cout << ans << endl;
}

```



**1969. 品种邻近**
题意:
n个数,  其中x, 满足有两个x在序列中的距离小于等于k.
找到最大的x, 如果没有输出-1

用滑动窗口维护, 因为每次区间长度是固定的
```cpp
#include <iostream>

using namespace std;

const int N = 50050, M = 1000010;

int n, k;
int a[N];
int ans = -1;
int num[M];

int main()
{
    cin >> n >> k;
    for (int i = 1; i <= n; i ++) cin >> a[i];
    for (int i = 1, j = 1; j <= n;) 
    {
        while (j - i <= k)
        {
            num[a[j]] ++;
            if (num[a[j]] > 1) ans = max(ans, a[j]);
            j ++;
        }
        num[a[i]] --;
        i ++;
    }
    cout << ans << endl;
}
```




登机牌条码【模拟/多项式除法】
```CPP
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int N = 2000, mod = 929;

int w, s, k;
char str[N];
int d[N], cnt;

void get_d()
{
    int mode = 0;
    for (int i = 0; str[i]; i++)
        if (str[i] >= 'A' && str[i] <= 'Z')
        {
            if (mode == 1)
                d[++cnt] = 28, d[++cnt] = 28;
            else if (mode == 2)
                d[++cnt] = 28;
            mode = 0, d[++cnt] = str[i] - 'A';
        }
        else if (str[i] >= 'a' && str[i] <= 'z')
        {
            if (mode != 1)
                d[++cnt] = 27;
            mode = 1, d[++cnt] = str[i] - 'a';
        }
        else
        {
            if (mode != 2)
                d[++cnt] = 28;
            mode = 2, d[++cnt] = str[i] - '0';
        }
    if (cnt & 1)
        d[++cnt] = 29;
    for (int i = 1, j = 1; i < cnt; i += 2, j++)
        d[j] = 30 * d[i] + d[i + 1];
    cnt >>= 1;
    while ((cnt + 1 + k) % w)
        d[++cnt] = 900;
    d[0] = cnt + 1;
}

int g[N];
void get_g()
{
    g[0] = 1;
    int r = -3;
    for (int i = 1; i <= k; r = r * 3 % mod, i++)
        for (int j = i - 1; j >= 0; j--)
            g[j + 1] = (g[j + 1] + g[j] * r) % mod;
}

int res[N];
int main()
{
    scanf("%d%d%s", &w, &s, str);
    k = ~s ? 1 << s + 1 : 0;
    get_d(), get_g();

    for (int i = 0; i <= cnt; i++)
        res[i] = d[i];
    for (int i = 0; i <= cnt; i++)
    {
        int r = res[i];
        res[i] = 0;
        for (int j = 1; j <= k; j++)
            res[i + j] = (res[i + j] - r * g[j]) % mod;
    }
    for (int i = 0; i <= cnt; i++)
        printf("%d\n", d[i]);
    for (int i = cnt + 1; i <= cnt + k; i++)
        printf("%d\n", (-res[i] % mod + mod) % mod);
}
```

带配额的文件系统【模拟/dfs】
```CPP
#include <iostream>
#include <cstring>
#include <algorithm>
#include <set>
#include <vector>

using namespace std;
typedef long long LL;

const int N = 2000020;

struct Node
{
    string name;
    int id, type;   // type -- 0:文件夹    1:文件
    mutable LL ld, lr;      // 目录配额，后代配额
    mutable LL sd, sr;      // 实际目录占用，实际后代占用
    bool operator< (const Node &t) const
    {
        return name < t.name;
    }
};

int n;
char str[N];      // 输入路径

set<Node> son[N];   // id为i文件夹的所有孩子的集合
int idx;            // 每个文件都有独一无二的编号，无论是现在存在的还是已经删除的。
LL SZ;      // 记录创建时，替换掉的源文件的大小
int U;      // 记录创建时，是从那一层开始创造出了新的路
/*
    比如原来有 A/B/C/x
    现在创建： A/B/D/y
    U = 2 [B这一层]
*/
bool F;     // 记录创建时，配额是否合法

vector<string> get(char* str)   // 将路径的每个部分分割开来，去除'/'存储在vector中
{
    vector<string> res(1, "root");  // 最开始都加上一个根目录节点root，便于存储以及其他计算
    for (int i = 0; str[i]; i ++)
    {
        if (str[i] == '/') continue;
        string s;
        int j = i;
        while (str[j] && str[j] != '/') s += str[j ++];
        res.push_back(s);
        i = j - 1;
    }
    return res;
}

LL dfs_remove(vector<string> &t, int u, int p)
{
    /*
        u: 遍历路径t的当前位置
        p: 文件夹编号
    */
    string name = t[u];
    if (son[p].count({name}) == 0) return -1;   // 没有此文件，直接返回-1

    auto it = son[p].find({name});

    if (u == t.size() - 1)      // 已经到路径的最后一个
    {
        if (it -> type == 1) t[u] = "#file";    // 标记这个文件被删了[作用在于修改上层文件夹的当前实际目录占用]
        auto sz = it->sr;   // 这个文件的实际大小
        son[p].erase(it);   // 将这个文件删除
        return sz;          // 返回删除文件的大小，递归改变父节点的后代实际大小
    }

    // 不是路径的最后一个

    // 是一个文件。证明路径错误，直接返回-1
    if (it->type) return -1;
    // 是文件夹，继续递归
    auto sz = dfs_remove(t, u + 1, it->id);

    // 递归结束，查看返回值(删除文件的大小)
    if (sz >= 0)
    {
        it->sr -= sz;
        if (t[u + 1] == "#file") it->sd -= sz;  // 这就是删除文件的上一层文件夹，修改实际目录占用
    }

    return sz;      // 继续回溯上一层 
}

bool dfs_create(vector<string> &t, int u, int p, LL sz)
{
    /*
        u: 遍历路径t的当前位置
        p: 文件夹编号
        sz: 要创建文件的大小
    */
    string name = t[u];
    if (u == t.size() - 1)      // 最后一步，要创建的东西
    {
        if (son[p].count({name}))   // 已经存在
        {
            auto it = son[p].find({name});
            if (it->type == 0) return false;    // 要创建的文件实际上现在有同名文件夹，创建失败
            SZ = dfs_remove(t, 0, 0);           // 替换原来的文件，先删除并修改配额，再创建新的文件.
            // SZ得到删除文件的配额
            Node cur{name, ++ idx, 1, 0, 0, 0, sz};
            son[p].insert(cur);
        }
        else    // 不存在同名文件，直接创建
        {
            Node cur{name, ++ idx, 1, 0, 0, 0, sz};
            son[p].insert(cur);
            return true;    // 成功创建
        }
    }
    else    // 还是再打开前面的文件夹过程中，没到最后一步
    {
        // 这里的 name 应该是一个文件夹。
        if (!son[p].count({name}))  // 不存在同名，创新的文件夹
        {
            if (U == -1) U = u;    // 记录新路径的起始位置
            Node cur{name, ++ idx, 0, 0, 0, 0, 0};
            son[p].insert(cur);
        }
        else    // 有同名
        {
            auto it = son[p].find({name});  
            if (it->type) return false;     // 同名文件，直接失败 
        }

        auto it = son[p].find({name});  // 当前的文件夹
        // 继续递归
        auto res = dfs_create(t, u + 1, it->id, sz);    // 得到返回的成功/失败消息
        if (res)    // 成功
        {
            it->sr += sz;
            if (u + 1 == t.size() - 1) it->sd += sz;

            if (it->lr && it->sr > it->lr) F = false;
            if (it->ld && it->sd > it->ld) F = false;
        }

        return res;
    }
}


bool create(char *str, LL sz)
{
    auto t = get(str);
    F = true, U = -1, SZ = -1;

    auto res = dfs_create(t, 0, 0, sz);

    auto flag = res && F;   // 是否同时满足创建合法和配额合法
    if (res && !F)  //   创建成功过但配额不合法，需要消除影响
    {
        auto t = get(str);
        if (U != -1)    // 证明开创了新的文件夹，要将新文件夹也删掉
        {
            while (t.size() - 1 > U) t.pop_back();
        }
        dfs_remove(t, 0, 0);

        if (SZ != -1) create(str, SZ);  //证明有被替换的文件, 重新创建
    }
    return flag;
}

bool update(char *str, LL d, LL r)
{
    auto t = get(str);
    int p = 0;  // 根目录编号
    for (int i = 0; i < t.size(); i ++)
    {
        string &s = t[i];
        if (!son[p].count({s})) return false;   // 修改配额的路径不存在，失败

        auto it = son[p].find({s});

        // if (it == son[p].end()) return false;  
        if (it->type) return false;     // 文件不能更新配额，失败。
        if (i == t.size() - 1)
        {
            if (d && d < it->sd) return false;  // 更新后小于实际当前目录下大小，失败
            if (r && r < it->sr) return false;  // 更新后小于实际后代大小，失败
            it->ld = d, it->lr = r;
        }
        p = it->id;
    }
    return true;
}

int main()
{
    int n;
    scanf("%d", &n);

    char op[2];

    sprintf(str, "/root");
    create(str, 1);
    auto t = get(str);
    dfs_remove(t, 0, 0);

    while (n -- )
    {
        scanf("%s", op);    // 读入操作
        bool ans;           // 判断指令是否成功

        if (*op == 'C')     // 创建
        {
            LL sz;
            scanf("%s%lld", str, &sz);
            ans = create(str, sz);
        }
        else if (*op == 'R')    // 删除，一定成功
        {
            scanf("%s", str);
            auto t = get(str);
            dfs_remove(t, 0, 0);
            ans = true;
        }
        else        // 修改配额
        {
            LL d, r;
            scanf("%s%lld%lld", str, &d, &r);
            ans = update(str, d, r);
        }

        if (ans) puts("Y");
        else puts("N");
    }
    return 0;
}
```
