# 板子

#### 目录

- 线段树
- 树链剖分
- 主席树
- vector实现treap
- 最短路
- 判负环
- Tarjan全家桶
- 差分约束系统
- 分层图
- 01分数规划
- 并查集
- 最小生成树
- 字典树











#### 1. 线段树   
- 区间加+区间求和     
```C++  
     struct node{  
        int l,r,sum,lz;  
     }tree[400400];  
     void pushup(int id)  
     {  
        tree[id].sum=tree[id*2].sum+tree[id*2+1].sum;  
     }  
     void pushdown(int id)  
     {  
        if(!tree[id].lz)return;  
        tree[id*2].lz+=tree[id].lz;  
        tree[id*2+1].lz+=tree[id].lz;  
        int mid=(tree[id].l+tree[id].r)/2;  
        tree[id*2].sum+=(mid-tree[id].l+1)*tree[id].lz;  
        tree[id*2+1].sum+=(tree[id].r-mid)*tree[id].lz;  
        tree[id].lz=0;  
     }  
     void build(int id,int l,int r)  
     {  
        tree[id].l=l;tree[id].r=r;  
        if(l==r)  
        {  
            tree[id].sum=num[l];  
            return;  
        }  
        int mid=(l+r)/2;  
        build(id*2,l,mid);  
        build(id*2+1,mid+1,r);  
        pushup(id);  
     }  
     void add(int id,int l,int r,int k)  
     {  
        if(l<=tree[id].l&&tree[id].r<=r)  
        {  
            tree[id].lz+=k;  
            tree[id].sum+=(tree[id].r-tree[id].l+1)*k;  
            return;  
        }  
        pushdown(id);  
        int mid=(tree[id].l+tree[id].r)/2;  
        if(l<=mid)add(id*2,l,r,k);  
        if(r>mid)add(id*2+1,l,r,k);  
        pushup(id);  
     }  
     int find(int id,int l,int r)  
     {  
        if(l<=tree[id].l&&tree[id].r<=r)return tree[id].sum;  
        pushdown(id);  
        int mid=(tree[id].l+tree[id].r)/2;  
        int sum=0;  
        if(l<=mid)sum+=find(id*2,l,r);  
        if(r>mid)sum+=find(id*2+1,l,r);  
        return sum;  
     }  
```

   - 区间加+区间乘+区间求和       
   ```c++  
     struct node{  
        int l,r,lz1,lz2,sum;  
     }tree[4*N];  
     void pushup(int id)  
     {  
        tree[id].sum=(tree[id*2].sum+tree[id*2+1].sum)%p;  
     }  
     void pushdown(int id)  
     {  
        int mid=(tree[id].l+tree[id].r)/2;   
        if(tree[id].lz2!=1)  
        {  
            tree[id*2].lz2=tree[id*2].lz2%p*tree[id].lz2%p;  
            tree[id*2].lz2%=p;  
            tree[id*2].lz1*=tree[id].lz2;  
            tree[id*2].lz1%=p;  
            tree[id*2+1].lz2=tree[id*2+1].lz2%p*tree[id].lz2%p;  
            tree[id*2+1].lz2%=p;  
            tree[id*2+1].lz1*=tree[id].lz2;  
            tree[id*2+1].lz1%=p;  
            tree[id*2].sum*=tree[id].lz2;  
            tree[id*2].sum%=p;  
            tree[id*2+1].sum*=tree[id].lz2;  
            tree[id*2+1].sum%=p;  
            tree[id].lz2=1;  
        }  
        if(tree[id].lz1)  
        {  
            tree[id*2].lz1+=tree[id].lz1;  
            tree[id*2].lz1%=p;  
            tree[id*2+1].lz1+=tree[id].lz1;  
            tree[id*2+1].lz1%=p;  
            tree[id*2].sum+=(mid-tree[id].l+1)*tree[id].lz1;  
            tree[id*2].sum%=p;  
            tree[id*2+1].sum+=(tree[id].r-mid)*tree[id].lz1;  
            tree[id*2+1].sum%=p;  
            tree[id].lz1=0;  
        }  
     }  
     void build(int id,int l,int r)  
     {  
        tree[id].l=l;tree[id].r=r;tree[id].lz2=1;  
        if(l==r)  
        {  
            tree[id].sum=num[l]%p;  
            return;  
        }  
        int mid=(l+r)/2;  
        build(id*2,l,mid);  
        build(id*2+1,mid+1,r);  
        pushup(id);  
     }  
     void add(int id,int l,int r,int k)  
     {  
        if(l<=tree[id].l&&tree[id].r<=r)  
        {  
            tree[id].lz1+=k;  
            tree[id].lz1%=p;  
            tree[id].sum+=(tree[id].r-tree[id].l+1)*k;  
            tree[id].sum%=p;  
            return;  
        }  
        pushdown(id);  
        int mid=(tree[id].l+tree[id].r)/2;  
        if(l<=mid)add(id*2,l,r,k);  
        if(r>mid)add(id*2+1,l,r,k);  
        pushup(id);  
     }  
     void multiply(int id,int l,int r,int k)  
     {  
        if(l<=tree[id].l&&tree[id].r<=r)  
        {  
            tree[id].lz2*=k;  
            tree[id].lz2%=p;  
            tree[id].sum*=k;  
            tree[id].sum%=p;  
            tree[id].lz1*=k;  
            tree[id].lz1%=p;  
            return;  
        }  
        pushdown(id);  
        int mid=(tree[id].l+tree[id].r)/2;  
        if(l<=mid)multiply(id*2,l,r,k);  
        if(r>mid)multiply(id*2+1,l,r,k);  
        pushup(id);  
     }  
     int find(int id,int l,int r)  
     {  
        if(l<=tree[id].l&&tree[id].r<=r)return tree[id].sum%p;  
        pushdown(id);  
        int mid=(tree[id].l+tree[id].r)/2;  
        int sum=0;  
        if(l<=mid)sum+=find(id*2,l,r),sum%=p;  
        if(r>mid)sum+=find(id*2+1,l,r),sum%=p;  
        return sum%p;  
     }  
   ```


- 区间加+区间覆盖+区间求和  
```C++  
  void pushup(int id)  
  {  
    tree[id].maxn=max(tree[id*2].maxn,tree[id*2+1].maxn);  
  }  
  void coverdown(int id)  
  {  
    if(!tree[id].f)return;  
    tree[id*2].f=tree[id*2+1].f=1;  
    tree[id].f=0;  
    tree[id*2].lz1=tree[id*2+1].lz1=0;  
    tree[id*2].lz2=tree[id*2+1].lz2=tree[id].lz2;  
    tree[id*2].maxn=tree[id*2+1].maxn=tree[id].lz2;  
  }  
  void sumdown(int id)  
  {  
    if(!tree[id].lz1)return;  
    tree[id*2].lz1+=tree[id].lz1;  
    tree[id*2+1].lz1+=tree[id].lz1;  
    tree[id*2].maxn+=tree[id].lz1;  
    tree[id*2+1].maxn+=tree[id].lz1;  
    tree[id].lz1=0;  
  }  
  void pushdown(int id)  
  {  
    coverdown(id);  
    sumdown(id);  
  }  
  void build(int id,int l,int r)  
  {  
    tree[id].l=l;tree[id].r=r;  
    if(l==r)  
    {  
        tree[id].maxn=num[l];  
        return;  
    }  
    int mid=(l+r)/2;  
    build(id*2,l,mid);  
    build(id*2+1,mid+1,r);  
    pushup(id);  
  }  
  void add(int id,int l,int r,int k)  
  {  
    if(l<=tree[id].l&&tree[id].r<=r)  
    {  
        coverdown(id);  
        tree[id].maxn+=k;  
        tree[id].lz1+=k;  
        return;  
    }  
    pushdown(id);  
    int mid=(tree[id].l+tree[id].r)/2;  
    if(l<=mid)add(id*2,l,r,k);  
    if(r>mid)add(id*2+1,l,r,k);  
    pushup(id);  
  }  
  void cover(int id,int l,int r,int k)  
  {  
    if(l<=tree[id].l&&tree[id].r<=r)  
    {  
        tree[id].f=1;  
        tree[id].lz2=k;  
        tree[id].maxn=k;  
        tree[id].lz1=0;  
        return;  
    }  
    pushdown(id);  
    int mid=(tree[id].l+tree[id].r)/2;  
    if(l<=mid)cover(id*2,l,r,k);  
    if(r>mid)cover(id*2+1,l,r,k);  
    pushup(id);  
  }  
  int find(int id,int l,int r)  
  {  
    if(l<=tree[id].l&&tree[id].r<=r)return tree[id].maxn;  
    pushdown(id);  
    int mid=(tree[id].l+tree[id].r)/2;  
    int sum=-inf;  
    if(l<=mid)sum=max(sum,find(id*2,l,r));  
    if(r>mid)sum=max(sum,find(id*2+1,l,r));  
    return sum;  
  }  
```

- 单点修改+区间最大字串和  
```C++  
  struct node{  
    int l,r,lm,rm,sum,maxn;  
      //lm:左端点为起点的最大值 rm:右端点为起点的最大值 maxn:区间最大值  }tree[4000100];  
  void pushup(int id)  
  {  
  tree[id].maxn=max(tree[id*2].rm+tree[id*2+1].lm,max(tree[id*2].maxn,tree[id*2+1].maxn));  
    tree[id].sum=tree[id*2].sum+tree[id*2+1].sum;  
    tree[id].lm=max(tree[id*2].lm,tree[id*2].sum+tree[id*2+1].lm);  
  tree[id].rm=max(tree[id*2+1].rm,tree[id*2+1].sum+tree[id*2].rm);  
  }  
  void build(int id,int l,int r)  
  {  
    tree[id].l=l;tree[id].r=r;  
    if(l==r)  
    {  
        tree[id].sum=tree[id].lm=tree[id].rm=tree[id].maxn=num[l];  
        return;  
    }  
    int mid=(l+r)/2;  
    build(id*2,l,mid);  
    build(id*2+1,mid+1,r);  
    pushup(id);  
  }  
  void add(int id,int p,int k)  
  {  
    if(tree[id].l==tree[id].r&&tree[id].l==p)  
    {  
        tree[id].lm=tree[id].rm=tree[id].maxn=tree[id].sum=k;  
        return ;  
    }  
    int mid=(tree[id].l+tree[id].r)/2;  
    if(p<=mid)add(id*2,p,k);  
    else add(id*2+1,p,k);  
    pushup(id);  
  }  
  node find(int id,int l,int r)  
  {  
    if(l<=tree[id].l&&tree[id].r<=r)return tree[id];  
    int mid=(tree[id].l+tree[id].r)/2;  
    if(r<=mid)return find(id*2,l,r);  
    else if(l>mid)return find(id*2+1,l,r);  
    else  
    {  
        node x=find(id*2,l,r),y=find(id*2+1,l,r),c;  
        c.maxn=max(max(x.maxn,y.maxn),x.rm+y.lm);  
        c.lm=max(x.lm,x.sum+y.lm);  
        c.rm=max(y.rm,y.sum+x.rm);  
        c.sum=x.sum+y.sum;  
        return c;  
    }  
  }  
  signed main()  
  {  
    scanf("%lld%lld",&n,&m);  
    for(int i=1;i<=n;++i)scanf("%lld",&num[i]);  
    build(1,1,n);  
    for(int i=1;i<=m;++i)  
    {  
        int x,y,k;  
        scanf("%lld",&k);  
        if(k==1)  
        {  
            scanf("%lld%lld",&x,&y);  
            if(x>y)swap(x,y);  
            printf("%lld\n",find(1,x,y).maxn);  
        }  
        else  
        {  
            scanf("%lld%lld",&x,&y);  
            add(1,x,y);  
        }  
    }  
    return 0;  
  }  
```

- 区间覆盖+区间最长连续子串  
```C++  
  struct node{  
    int l,r,lm,rm,maxn;  
      //lm:左端点为起点最长连续字串长度 rm:右端点为起点最长连续字串长度 maxn:区间最长连续字串长度  }tree[800800];  
  void pushup(int id)  
  {  
    tree[id].lm=tree[id*2].lm;tree[id].rm=tree[id*2+1].rm;  
    int cur=0;int mid=(tree[id].l+tree[id].r)/2;  
    if(num[mid]^num[mid+1])  
    {  
        if(tree[id*2].lm==(mid-tree[id].l+1))tree[id].lm+=tree[id*2+1].lm;  
        if(tree[id*2+1].rm==(tree[id].r-mid))tree[id].rm+=tree[id*2].rm;  
        cur=tree[id*2].rm+tree[id*2+1].lm;   
    }  
    tree[id].maxn=max(cur,max(tree[id*2].maxn,tree[id*2+1].maxn));  
  }  
  void build(int id,int l,int r)  
  {  
    tree[id].l=l;tree[id].r=r;  
    if(l==r)  
    {  
        tree[id].lm=tree[id].rm=tree[id].maxn=1;  
        return;  
    }  
    int mid=(l+r)/2;  
    build(id*2,l,mid);  
    build(id*2+1,mid+1,r);  
    pushup(id);  
  }  
  void change(int id,int p)  
  {  
    if(tree[id].l==tree[id].r)  
    {  
        tree[id].lm=tree[id].rm=tree[id].maxn=1;  
        return;  
    }  
    int mid=(tree[id].l+tree[id].r)/2;  
    if(p<=mid)change(id*2,p);  
    else change(id*2+1,p);  
    pushup(id);  
  }  
```

- 区间覆盖+查询长度为x的连续区间的最小位置  
```c++  
  struct node{  
    int l,r,lm,rm,sum,lz,len;  
      //lm:左端点开始的最大连续子串长度 sum:区间最大连续字串长度 len:区间长度    bool flag;  
  }tree[4000100];  
  void pushup(int id)  
  {  
  if(tree[id*2].sum==tree[id*2].len)tree[id].lm=tree[id*2].len+tree[id*2+1].lm;  
    else tree[id].lm=tree[id*2].lm;  
  if(tree[id*2+1].sum==tree[id*2+1].len)tree[id].rm=tree[id*2+1].len+tree[id*2].rm;  
    else tree[id].rm=tree[id*2+1].rm;                        tree[id].sum=max(max(tree[id*2].sum,tree[id*2+1].sum),tree[id*2].rm+tree[id*2+1].lm);  
  //三种情况：左最长，右最长，左右合并最长  }  
  void pushdown(int id)  
  {  
    if(!tree[id].flag)return;  
    tree[id*2].lz=tree[id].lz;  
    tree[id*2+1].lz=tree[id].lz;  
    tree[id*2].flag=1;  
    tree[id*2+1].flag=1;  
    tree[id*2].sum=tree[id*2].len*tree[id].lz;  
    tree[id*2+1].sum=tree[id*2+1].len*tree[id].lz;  
    tree[id*2].lm=tree[id*2].rm=tree[id*2].sum;  
    tree[id*2+1].lm=tree[id*2+1].rm=tree[id*2+1].sum;  
    tree[id].flag=0;  
    tree[id].lz=0;  
  }  
  void build(int id,int l,int r)  
  {  
    tree[id].l=l;tree[id].r=r;  
    tree[id].len=r-l+1;  
    tree[id].lm=tree[id].rm=tree[id].sum=tree[id].len;  
    if(l==r)return;  
    int mid=(l+r)/2;  
    build(id*2,l,mid);  
    build(id*2+1,mid+1,r);  
  }  
  void make(int id,int l,int r,int k)  
  {  
    if(l<=tree[id].l&&tree[id].r<=r)  
    {  
        tree[id].flag=1;  
        tree[id].lz=k;  
        tree[id].sum=tree[id].len*k;  
        tree[id].lm=tree[id].rm=tree[id].sum;  
        return;  
    }  
    pushdown(id);  
    int mid=(tree[id].l+tree[id].r)/2;  
    if(l<=mid)make(id*2,l,r,k);  
    if(r>mid)make(id*2+1,l,r,k);  
    pushup(id);  
  }  
  int find(int id,int k)  
  {  
    if(tree[id].l==tree[id].r)return tree[id].l;  
    pushdown(id);  
    int mid=(tree[id].l+tree[id].r)/2;  
    if(tree[id*2].sum>=k)return find(id*2,k);//左儿子可以就查找左儿子    if(tree[id*2].rm+tree[id*2+1].lm>=k) return mid-tree[id*2].rm+1;  
      //否则看看两个区间是否被可以合并出满足题意的    return find(id*2+1,k);//最后查询右儿子  }  
  int main()  
  {  
    scanf("%d%d",&n,&m);  
    build(1,1,n);  
    for(int i=1;i<=m;++i)  
    {  
        int x,y,k;  
        scanf("%d",&k);  
        if(k==1)  
        {  
            scanf("%d",&x);  
            if(tree[1].sum>=x)  
            {  
               ans=find(1,x);  
               printf("%d\n",ans);  
               make(1,ans,ans+x-1,0);  
            }  
            else printf("0\n");  
        }  
        else  
        {  
            scanf("%d%d",&x,&y);  
            make(1,x,x+y-1,1);  
        }  
    }  
    return 0;  
  }  
```

- 区间修改成回文串  
```C++  
  struct node{  
    int l,r,sum,lz;  //对于每一个字母开一棵线段树，维护区间数目  
  }tree[N*4][30];  
  void pushup(int id,int p)  
  {  
    tree[id][p].sum=tree[id*2][p].sum+tree[id*2+1][p].sum;  
  }  
  void pushdown(int id,int p)  
  {  
    if(tree[id][p].lz==-1)return ;  
    tree[id*2][p].lz=tree[id][p].lz;  
    tree[id*2+1][p].lz=tree[id][p].lz;  
    int mid=(tree[id][p].l+tree[id][p].r)/2;  
    tree[id*2][p].sum=tree[id][p].lz*(mid-tree[id][p].l+1);  
    tree[id*2+1][p].sum=tree[id][p].lz*(tree[id][p].r-mid);  
    tree[id][p].lz=-1;  
  }  
  void build(int id,int l,int r)  
  {  
    for(int i=0;i<26;++i)  
    {  
        tree[id][i].l=l;  
        tree[id][i].r=r;  
        tree[id][i].lz=-1;  
    }  
    if(l==r)  
    {  
        tree[id][s[l-1]-'a'].sum=1;  
        return;  
    }  
    int mid=(l+r)/2;  
    build(id*2,l,mid);  
    build(id*2+1,mid+1,r);  
    for(int i=0;i<26;++i)pushup(id,i);  
  }  
  void cover(int id,int l,int r,int p,int k)  
  {  
    if(l<=tree[id][p].l&&tree[id][p].r<=r)  
    {  
        tree[id][p].sum=(tree[id][p].r-tree[id][p].l+1)*k;  
        tree[id][p].lz=k;  
        return;  
    }  
    pushdown(id,p);  
    int mid=(tree[id][p].l+tree[id][p].r)/2;  
    if(l<=mid)cover(id*2,l,r,p,k);  
    if(r>mid)cover(id*2+1,l,r,p,k);  
    pushup(id,p);  
  }  
  int find(int id,int l,int r,int p)  
  {  
  if(l<=tree[id][p].l&&tree[id][p].r<=r)return tree[id][p].sum;  
    pushdown(id,p);  
    int sum=0;int mid=(tree[id][p].l+tree[id][p].r)/2;  
    if(l<=mid)sum+=find(id*2,l,r,p);  
    if(r>mid)sum+=find(id*2+1,l,r,p);  
    return sum;  
  }  
  int main()  
  {  
    scanf("%d%d",&n,&m);  
    scanf("\n%s",s);  
    build(1,1,n);  
    for(int i=1;i<=m;++i)  
    {  
        int x,y;  
        scanf("%d%d",&x,&y);  
        for(int j=0;j<26;++j)tmp[j]=find(1,x,y,j);//存储当前的字符串        
        int tot=0,id=-1;  
        for(int j=0;j<26;++j)  
            if(tmp[j]%2)++tot,id=j;//寻找中间节点        
        if(tot>1)continue;  
        for(int j=0;j<26;++j)cover(1,x,y,j,0);  
        if(tot==1)  
        {  
            --tmp[id];  
            cover(1,(x+y)/2,(x+y)/2,id,1);  
        }  
        int l=x,r=y;  
        for(int j=0;j<26;++j)//对于每一个字母进行区间覆盖        
        {  
            if(!tmp[j])continue;  
            int cur=tmp[j]/2;  
            cover(1,l,l+cur-1,j,1);  
            cover(1,r-cur+1,r,j,1);  
            l+=cur;  
            r-=(tmp[j]-cur);  
        }  
    }  
    for(int i=1;i<=n;++i)  
    {  
        for(int j=0;j<26;++j)  
        {  
            int cur=find(1,i,i,j);  
            if(cur)  
            {  
               printf("%c",j+'a');  
               break;  
            }  
        }  
    }  
    return 0;  
  }  
```

- 区间染色+统计区间颜色个数（颜色种类$\leq$ 60）  
```C++  
  struct node{  
    int l,r,lz,c,sum;  //状态压缩，c代表区间染色情况：第i位为1，表示该区间有第i种颜色  
  }tree[400400];  
  inline void pushup(int id)  
  {  
    tree[id].c=tree[id*2].c|tree[id*2+1].c;  
  }  
  void pushdown(int id)  
  {  
    if(!tree[id].lz)return;  
    tree[id*2].lz=tree[id].lz;  
    tree[id*2+1].lz=tree[id].lz;  
    tree[id*2].c=1<<(tree[id].lz-1);  
    tree[id*2+1].c=1<<(tree[id].lz-1);  
    tree[id].lz=0;  
  }  
  void build(int id,int l,int r)  
  {  
    tree[id].l=l;tree[id].r=r;  
    if(l==r)  
    {  
        tree[id].c=1;  
        return;  
    }  
    int mid=(l+r)/2;  
    build(id*2,l,mid);  
    build(id*2+1,mid+1,r);  
    pushup(id);  
  }  
  void make(int id,int l,int r,int k)  
  {  
    if(l<=tree[id].l&&tree[id].r<=r)  
    {  
        tree[id].c=1<<(k-1);  
        tree[id].lz=k;  
        return;  
    }  
    pushdown(id);  
    int mid=(tree[id].l+tree[id].r)/2;  
    if(l<=mid)make(id*2,l,r,k);  
    if(r>mid)make(id*2+1,l,r,k);  
    pushup(id);  
  }  
  int find(int id,int l,int r)  
  {  
    if(l<=tree[id].l&&tree[id].r<=r)return tree[id].c;  
    pushdown(id);  
    int mid=(tree[id].l+tree[id].r)/2;  
    int k=0;  
    if(l<=mid)k|=find(id*2,l,r);  
    if(r>mid)k|=find(id*2+1,l,r);  
    return k;  
  }//最后将返回的答案进行拆分即可  ```  
```
- 区间染色+查询区间颜色数目（颜色种类很大）  

  ```  C++
  //差分的思想，当某一个区间进行染色时，统计区间的起点与终点。查询时利用差分的性质来搞  
  struct node{  
    int l,r,sum;  
  }tree1[400400],tree2[400400];//tree1统计起点，tree2统计终点  
  void pushup(int id,node *tree)  
  {  
    tree[id].sum=tree[id*2].sum+tree[id*2+1].sum;  
  }  
  void build(int id,int l,int r,node *tree)  
  {  
    tree[id].l=l;tree[id].r=r;  
    if(l==r)return;  
    int mid=(l+r)/2;  
    build(id*2,l,mid,tree);  
    build(id*2+1,mid+1,r,tree);  
    pushup(id,tree);  
  }  
  void add(int id,int k,int p,node *tree)  
  {  
    if(tree[id].l==tree[id].r&&tree[id].l==k)  
    {  
        tree[id].sum+=p;  
        return;  
    }  
    int mid=(tree[id].l+tree[id].r)/2;  
    if(k<=mid)add(id*2,k,p,tree);  
    if(k>mid)add(id*2+1,k,p,tree);  
    pushup(id,tree);  
  }  
  int find(int id,int l,int r,node *tree)  
  {  
    if(l<=tree[id].l&&tree[id].r<=r)return tree[id].sum;  
    int mid=(tree[id].l+tree[id].r)/2;  
    int sum=0;  
    if(l<=mid)sum+=find(id*2,l,r,tree);  
    if(r>mid)sum+=find(id*2+1,l,r,tree);  
    return sum;  
  }  
  int main()  
  {  
    scanf("%d%d",&n,&m);  
    build(1,1,n,tree1);  
    build(1,1,n,tree2);  
    for(int i=1;i<=m;++i)  
    {  
        int x,y,z;  
        scanf("%d%d%d",&z,&x,&y);  
        if(z==1)  
        {  
            add(1,x,1,tree1);  
            add(1,y,1,tree2);  
        }  
        else  
        {  
            int aa=find(1,1,y,tree1),bb=find(1,1,x-1,tree2);  
            print
            f("%d\n",aa-bb);  
        }  
    }  
    return 0;  
  }  
  ```


- `1 l r K D`：给出一个长度等于 $r-l+1$ 的等差数列，首项为 $K$，公差为 $D$，并将它对应加到 $[l,r]$ 范围中的每一个数上。即：令$ a_l=a_l+K,a_{l+1}=a_{l+1}+K+D\ldots a_r=a_r+K+(r-l) \times D$。  
- `2 p`：询问序列的第 $p$ 个数的值 $a_p$。 
 ```C++  
  //我们可以发现，增加等差数列后区间的差分值没有改变  //线段树维护差分数组，单点修改增加等差数列的首项，区间修改增加公差，区间求和  
struct node{  
    int l,r;  
    ll sum,lz;  
  }tree[5005000];  
  inline void pushup(int id)  
  {  
    tree[id].sum=tree[id*2].sum+tree[id*2+1].sum;  
  }  
  inline void pushdown(int id)  
  {  
    if(!tree[id].lz)return;  
    tree[id*2].lz+=tree[id].lz;  
    tree[id*2+1].lz+=tree[id].lz;  
    int mid=(tree[id].l+tree[id].r)/2;  
    tree[id*2].sum+=(mid-tree[id].l+1)*tree[id].lz;  
    tree[id*2+1].sum+=(tree[id].r-mid)*tree[id].lz;  
    tree[id].lz=0;  
  }  
  void build(int id,int l,int r)  
  {  
    tree[id].l=l;tree[id].r=r;  
    if(l==r)  
    {  
        tree[id].sum=cha[l];  
        return;  
    }  
    int mid=(l+r)/2;  
    build(id*2,l,mid);  
    build(id*2+1,mid+1,r);  
    pushup(id);  
  }  
  void addd(int id,int p,ll k)//单点修改  {  
    if(tree[id].l==tree[id].r&&tree[id].l==p)  
    {  
        tree[id].sum+=k;  
        return;  
    }  
    pushdown(id);  
    int mid=(tree[id].l+tree[id].r)/2;  
    if(p<=mid)addd(id*2,p,k);  
    if(p>mid)addd(id*2+1,p,k);  
    pushup(id);  
  }  
  void addq(int id,int l,int r,ll k)//区间修改  {  
    if(l<=tree[id].l&&tree[id].r<=r)  
    {  
        tree[id].lz+=k;  
        tree[id].sum+=(tree[id].r-tree[id].l+1)*k;  
        return;  
    }  
    pushdown(id);  
    int mid=(tree[id].l+tree[id].r)/2;  
    if(l<=mid)addq(id*2,l,r,k);  
    if(r>mid)addq(id*2+1,l,r,k);  
    pushup(id);  
  }  
  ll find(int id,int l,int r)  
  {  
    if(l<=tree[id].l&&tree[id].r<=r)return tree[id].sum;  
    pushdown(id);  
    ll sum=0;  
    int mid=(tree[id].l+tree[id].r)/2;  
    if(l<=mid)sum+=find(id*2,l,r);  
    if(r>mid)sum+=find(id*2+1,l,r);  
    return sum;  
  }  
  int main()  
  {  
    scanf("%d%d",&n,&m);  
    for(int i=1;i<=n;++i)  
    {  
        scanf("%lld",&num[i]);  
        cha[i]=num[i]-num[i-1];  
    }  
    build(1,1,n);  
    for(int i=1;i<=m;++i)  
    {  
        int l,r,k;  
        ll s,d;  
        scanf("%d",&k);  
        if(k==1)  
        {  
            scanf("%d%d%lld%lld",&l,&r,&s,&d);  
            addd(1,l,s);  
            ll cur=s+(r-l)*d;  
            if(r<n)addd(1,r+1,-cur);  
            if(l<r)addq(1,l+1,r,d);  
        }  
        else  
        {  
            int p;  
            scanf("%d",&p);  
            ll ans=find(1,1,p);  
            printf("%lld\n",ans);  
        }  
    }  
    return 0;  
  }  
 ```

- 区间开方+区间求和  
```C++  
  struct node{  
    int l,r;  
    ll maxn,sum;//当区间最大值为1时，不需要进行开方  
  }tree[400400];  
  inline void pushup(int id)  
  {  
    tree[id].sum=tree[id*2].sum+tree[id*2+1].sum;  
    tree[id].maxn=max(tree[id*2].maxn,tree[id*2+1].maxn);  
  }  
  void build(int id,int l,int r)  
  {  
    tree[id].l=l;tree[id].r=r;  
    if(l==r)  
    {  
        tree[id].sum=num[l];  
        tree[id].maxn=num[l];  
        return;  
    }  
    int mid=(l+r)/2;  
    build(id*2,l,mid);  
    build(id*2+1,mid+1,r);  
    pushup(id);  
  }  
  void make(int id,int l,int r)  
  {  
    if(tree[id].maxn<=1)return;  
    if(tree[id].l==tree[id].r&&l<=tree[id].l&&tree[id].r<=r)  
    {  
        ll cur=sqrt(tree[id].sum);  
        tree[id].sum=cur;  
        tree[id].maxn=cur;  
        return;  
    }  
    int mid=(tree[id].l+tree[id].r)/2;  
    if(l<=mid)make(id*2,l,r);  
    if(r>mid)make(id*2+1,l,r);  
    pushup(id);  
  }  
  ll find(int id,int l,int r)  
  {  
    if(l<=tree[id].l&&tree[id].r<=r)return tree[id].sum;  
    int mid=(tree[id].l+tree[id].r)/2;  
    ll ans=0;  
    if(l<=mid)ans+=find(id*2,l,r);  
    if(r>mid)ans+=find(id*2+1,l,r);  
    return ans;  
  }
```

- 权值线段树  在含有 $n$个整数的序列 $a_1,a_2,\ldots,a_n$ 中，三个数被称作`thair`当且仅当 $i<j<k$ 且 $a_i<a_j<a_k$。  求一个序列中 `thair` 的个数。  
```C++  
  int n,tot,cnt;  
  ll ans,sum;  
  ll num[100100],b[100100],minx[100100],maxn[100100];  
  struct node{  
    int l,r;  
    ll sum;int ls,rs;  
  }tree[400400];  
  #define lc tree[id].ls  
  #define rc tree[id].rs  
  void pushup(int id)  
  {  
    tree[id].sum=tree[lc].sum+tree[rc].sum;  
  }  
  void build(int &id,int l,int r)  
  {  
    id=++tot;  
    tree[id].l=l;tree[id].r=r;  
    if(l==r)  
    {  
        tree[id].sum=0;  
        return;  
    }  
    int mid=(l+r)/2;  
    build(lc,l,mid);  
    build(rc,mid+1,r);  
    pushup(id);  
  }  
  void add(int id,int p)  
  {  
    if(tree[id].l==tree[id].r)  
    {  
        tree[id].sum++;  
        return;  
    }  
    int mid=(tree[id].l+tree[id].r)/2;  
    if(p<=mid)add(lc,p);  
    else add(rc,p);  
    pushup(id);  
  }  
  int find(int id,int l,int r)  
  {  
    if(l<=tree[id].l&&tree[id].r<=r)return tree[id].sum;  
    int mid=(tree[id].l+tree[id].r)/2;  
    int sum=0;  
    if(l<=mid)sum+=find(lc,l,r);  
    if(r>mid)sum+=find(rc,l,r);  
    return sum;  
  }  
  signed main()  
  {  
    scanf("%d",&n);  
    for(int i=1;i<=n;++i)  
    {  
        scanf("%lld",&num[i]);  
        b[i]=num[i];  
    }  
    sort(b+1,b+1+n);  
    int top=unique(b+1,b+1+n)-b-1;  
    build(cnt,1,top);  
    for(int i=1;i<=n;++i)  
    {  
        int p=lower_bound(b+1,b+1+top,num[i])-b;  
        add(1,p);  
        minx[i]=find(1,1,p-1);  
    }  
    cnt=0;tot=0;  
    build(cnt,1,top);  
    for(int i=n;i>0;--i)  
    {  
        int p=lower_bound(b+1,b+1+top,num[i])-b;  
        add(1,p);  
        maxn[i]=find(1,p+1,top);  
    }  
    for(int i=1;i<=n;++i)ans+=minx[i]*maxn[i];  
    printf("%lld",ans);  
    return 0;  
  }  
```

动态开点

```C++
int n,m,tot,cnt;
struct node{
	int ls,rs,lz,sum;//区间覆盖&&区间求和
}tree[15001000];
inline void pushup(int id)
{
	tree[id].sum=tree[lc].sum+tree[rc].sum;
}
void pushdown(int id,int L,int R)
{
	if(tree[id].lz==-1)return;
	if(!lc)lc=++tot;
	if(!rc)rc=++tot;
	tree[lc].lz=tree[id].lz;
	tree[rc].lz=tree[id].lz;
	tree[lc].sum=(mid-L+1)*tree[id].lz;
	tree[rc].sum=(R-mid)*tree[id].lz;
	tree[id].lz=-1;
}
void make(int &id,int l,int r,int L,int R,int k)
{
	if(!id)
	{
		id=++tot;
		tree[id].lz=-1;
	}
	if(l<=L&&R<=r)
	{
		tree[id].lz=k;
		tree[id].sum=(R-L+1)*k;
		return;
	}
	pushdown(id,L,R);
	if(l<=mid)make(lc,l,r,L,mid,k);
	if(r>mid)make(rc,l,r,mid+1,R,k);
	pushup(id);
}
int main()
{
	n=read();m=read();
	make(cnt,1,n,1,n,0);
	int k,x,y;
	for(int i=1;i<=m;++i)
	{
		x=read();y=read();k=read();
		make(cnt,x,y,1,n,2-k);
		printf("%d\n",n-tree[1].sum);
	}
	return 0;
}
```



扫描线

```C++
int n,cnt,ans;
int x[1001000];
struct node{
	int l,r,h,k;
	bool operator<(node &b)
	{
		return h<=b.h;
	}
}p[2002000];
struct Tree{
	int l,r,sum,len;//len记录该区间被截出来的长度，sum为覆盖的次数
}tree[8008000];
void pushup(int id)
{
	int l=tree[id].l,r=tree[id].r;
	if(tree[id].sum)tree[id].len=(x[r+1]-x[l]);
	else tree[id].len=(tree[id*2].len+tree[id*2+1].len);
}
void build(int id,int l,int r)
{
	tree[id].l=l;tree[id].r=r;
	if(l==r)return;
	int mid=(l+r)/2;
	build(id*2,l,mid);
	build(id*2+1,mid+1,r);
	pushup(id);
}
void add(int id,int L,int R,int k)
{
	int l=tree[id].l,r=tree[id].r;
	if(x[r+1]<=L||x[l]>=R)return;
	if(L<=x[l]&&x[r+1]<=R)
	{
		tree[id].sum+=k;
		pushup(id);
		return;
	}
	add(id*2,L,R,k);
	add(id*2+1,L,R,k);
	pushup(id);
}
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;++i)
	{
		int x1,y1,x2,y2;
		scanf("%lld%lld%lld%lld",&x1,&y1,&x2,&y2);
		x[2*i-1]=x1;
		x[2*i]=x2;
		p[2*i-1]=(node){x1,x2,y1,1};
		p[2*i]=(node){x1,x2,y2,-1};
	}
	cnt=n*2;
	sort(p+1,p+1+cnt);
	sort(x+1,x+1+cnt);
	int tot=unique(x+1,x+1+cnt)-x-1;
	build(1,1,tot-1);
	for(int i=1;i<cnt;++i)
	{
		add(1,p[i].l,p[i].r,p[i].k);
		ans+=tree[1].len*(p[i+1].h-p[i].h);
	}
	printf("%lld",ans);
	return 0;
}
```



#### 2.树链剖分

- 树剖求$LCA$  
  ```C++  
  int n,m,t,tot,cnt;  
  int dep[N],son[N],head[N],siz[N],fa[N],dfn[N],rk[N],tp[N];  
  struct node{  
    int nxt,to;  
  }edge[N*2];  
  void add(int from,int to)  
  {  
    edge[++cnt].nxt=head[from];  
    edge[cnt].to=to;  
    head[from]=cnt;  
  }  
  void dfs1(int s,int pre)  
  {  
    siz[s]=1;  
    dep[s]=dep[pre]+1;  
    fa[s]=pre;  
    for(int i=head[s];i;i=edge[i].nxt)  
    {  
        int nxt=edge[i].to;  
        if(nxt==pre)continue;  
        dfs1(nxt,s);  
        siz[s]+=siz[nxt];  
        if(siz[nxt]>siz[son[s]])son[s]=nxt;  
    }  
  }  
  void dfs2(int s,int top)  
  {  
    tp[s]=top;  
    dfn[s]=++tot;  
    rk[tot]=s;  
    if(son[s])dfs2(son[s],top);  
    for(int i=head[s];i;i=edge[i].nxt)  
    {  
        int nxt=edge[i].to;  
        if(nxt==fa[s]||nxt==son[s])continue;  
        dfs2(nxt,nxt);  
    }  
  }  
  int find(int x,int y)  
  {  
    while(tp[x]!=tp[y])  
    {  
        if(dep[tp[x]]<dep[tp[y]])swap(x,y);  
        x=tp[x];  
        x=fa[x];  
    }  
    return dep[x]>dep[y]?y:x;  
  }  
  ```

- 附：倍增LCA  

  ```C++  
  struct node{  
    int nxt,to;  
  }edge[1001000];  
  void add(int from,int to)  
  {  
    edge[++cnt].nxt=head[from];  
    edge[cnt].to=to;  
    head[from]=cnt;  
  }  
  void init()  
  {  
    for(int i=1;i<=30;++i)  
        for(int j=1;j<=n;++j)f[j][i]=f[f[j][i-1]][i-1];  
  }  
  void dfs(int s)  
  {  
    for(int i=head[s];i;i=edge[i].nxt)  
    {  
        int nxt=edge[i].to;  
        if(nxt==fa[s])continue;  
        fa[nxt]=s;  
        f[nxt][0]=s;  
        dep[nxt]=dep[s]+1;  
        dfs(nxt);  
    }  
  }  
  int lca(int x,int y)  
  {  
    if(dep[x]<dep[y])swap(x,y);  
    int t=dep[x]-dep[y];  
    for(int i=30;i>=0;--i)  
        if((t>>i)&1)x=f[x][i];  
    if(x==y)return x;  
    for(int i=30;i>=0;--i)  
    {  
        if((1<<i)>n)continue;  
        if(f[x][i]!=f[y][i])  
        {  
            x=f[x][i];  
            y=f[y][i];  
        }  
    }  
    return f[x][0];  
  }  
  int main()  
  {  
    scanf("%d%d%d",&n,&m,&k);  
    for(int i=1;i<n;++i)  
    {  
        int a,b;  
        scanf("%d%d",&a,&b);  
        add(a,b);  
        add(b,a);  
    }  
    for(int i=1;i<=n;++i)f[i][0]=edge[i].to;  
    f[k][0]=0;  
    dfs(k);  
    init();  
    for(int i=1;i<=m;++i)  
    {  
        int a,b;  
        scanf("%d%d",&a,&b);  
        printf("%d\n",lca(a,b));  
    }  
    return 0;  
  }  
  ```

   

- 树剖+线段树  
```C++  
  int n,m,cnt,s,mod,tot;  
  int num[N],dep[N],fa[N],dfn[N],tp[N],rk[N],siz[N],son[N],head[N];  
  struct Edge{  
    int nxt,to;  
  }edge[N*2];  
  struct Tree{  
    int l,r,lz,sum;  
  }tree[N*4];  
  void add(int from,int to)  
  {  
    edge[++cnt].nxt=head[from];  
    edge[cnt].to=to;  
    head[from]=cnt;  
  }  
  void dfs1(int s,int pre)  
  {  
    fa[s]=pre;  
    dep[s]=dep[pre]+1;  
    siz[s]=1;  
    for(int i=head[s];i;i=edge[i].nxt)  
    {  
        int nxt=edge[i].to;  
        if(nxt==pre)continue;  
        dfs1(nxt,s);  
        siz[s]+=siz[nxt];  
        if(siz[nxt]>siz[son[s]])son[s]=nxt;  
    }  
  }  
  void dfs2(int s,int top)  
  {  
    tp[s]=top;  
    dfn[s]=++tot;  
    rk[tot]=s;  
    if(son[s])dfs2(son[s],top);  
    for(int i=head[s];i;i=edge[i].nxt)  
    {  
        int nxt=edge[i].to;  
        if(nxt==fa[s]||nxt==son[s])continue;  
        dfs2(nxt,nxt);  
    }  
  }  
  void pushup(int id)  
  {  
    tree[id].sum=(tree[id*2].sum%mod+tree[id*2+1].sum%mod)%mod;  
  }  
  void pushdown(int id)  
  {  
    if(!tree[id].lz)return;  
    int mid=(tree[id].l+tree[id].r)/2;  
    tree[id*2].lz+=tree[id].lz;tree[id*2].lz%=mod;  
    tree[id*2+1].lz+=tree[id].lz;tree[id*2+1].lz%=mod;  
    tree[id*2].sum=((mid-tree[id].l+1)*tree[id].lz+tree[id*2].sum)%mod;  
    tree[id*2+1].sum=((tree[id].r-mid)*tree[id].lz+tree[id*2+1].sum)%mod;  
    tree[id].lz=0;  
  }  
  void build(int id,int l,int r)  
  {  
    tree[id].l=l;tree[id].r=r;  
    if(l==r)  
    {  
        tree[id].sum=num[rk[l]]%mod;  
        return;  
    }  
    int mid=(l+r)/2;  
    build(id*2,l,mid);  
    build(id*2+1,mid+1,r);  
    pushup(id);  
  }  
  void add(int id,int l,int r,int k)  
  {  
    if(l<=tree[id].l&&tree[id].r<=r)  
    {  
        tree[id].lz+=k;  
        tree[id].lz%=mod;  
        tree[id].sum=((tree[id].r-tree[id].l+1)*k+tree[id].sum)%mod;  
        return;  
    }  
    pushdown(id);  
    int mid=(tree[id].l+tree[id].r)/2;  
    if(l<=mid)add(id*2,l,r,k);  
    if(r>mid)add(id*2+1,l,r,k);  
    pushup(id);  
  }  
  int find(int id,int l,int r)  
  {  
    if(l<=tree[id].l&&tree[id].r<=r)return tree[id].sum%mod;  
    pushdown(id);  
    int mid=(tree[id].l+tree[id].r)/2;  
    int sum=0;  
    if(l<=mid)sum=(find(id*2,l,r)+sum)%mod;  
    if(r>mid)sum=(find(id*2+1,l,r)+sum)%mod;  
    return sum%mod;  
  }  
  void addf(int x,int y,int k)  
  {  
    while(tp[x]!=tp[y])  
    {  
        if(dep[tp[x]]<dep[tp[y]])swap(x,y);  
        add(1,dfn[tp[x]],dfn[x],k);  
        x=tp[x];  
        x=fa[x];  
    }  
    if(dep[x]<dep[y])swap(x,y);  
    add(1,dfn[y],dfn[x],k);  
  }  
  int sumf(int x,int y)  
  {  
    int sum=0;  
    while(tp[x]!=tp[y])  
    {  
        if(dep[tp[x]]<dep[tp[y]])swap(x,y);  
        sum=(find(1,dfn[tp[x]],dfn[x])+sum)%mod;  
        x=tp[x];  
        x=fa[x];  
    }  
    if(dep[x]<dep[y])swap(x,y);  
    sum=(sum+find(1,dfn[y],dfn[x]))%mod;  
    return sum%mod;  
  }  
  signed main()  
  {  
    scanf("%lld%lld%lld%lld",&n,&m,&s,&mod);  
    for(int i=1;i<=n;++i)scanf("%lld",&num[i]);  
    for(int i=1;i<n;++i)  
    {  
        int x,y;  
        scanf("%lld%lld",&x,&y);  
        add(x,y);  
        add(y,x);  
    }  
    dfs1(s,0);  
    dfs2(s,s);  
    build(1,1,tot);  
    for(int i=1;i<=m;++i)  
    {  
        int x,y,z,k;  
        scanf("%lld",&k);  
        if(k==1)//单点点权修改        {  
            scanf("%lld%lld%lld",&x,&y,&z);  
            z%=mod;  
            addf(x,y,z);  
        }  
        else if(k==2)//路径点权求和        {  
            scanf("%lld%lld",&x,&y);  
            printf("%lld\n",sumf(x,y));  
        }  
        else if(k==3)//子树点权修改        {  
            scanf("%lld%lld",&x,&z);  
            z%=mod;  
            add(1,dfn[x],dfn[x]+siz[x]-1,z);  
        }  
        else//子树点权求和        {  
            scanf("%lld",&x);  
            printf("%lld\n",find(1,dfn[x],dfn[x]+siz[x]-1)%mod);  
        }  
    }  
    return 0;  
  }  
```


#### 3. 主席树

```C++  
int n,m,tot,p;  
int num[N],a[N],rt[N],sum[N<<5],ls[N<<5],rs[N<<5];  
void build(int &id,int l,int r)  
{  
    id= ++tot;  
    if(l==r)return;  
    int mid=(l+r)/2;  
    build(ls[id],l,mid);  
    build(rs[id],mid+1,r);  
}  
int change(int id,int l,int r)  
{  
    int cur= ++tot;  
    ls[cur]=ls[id];  
    rs[cur]=rs[id];  
    sum[cur]=sum[id]+1;  
    if(l==r)return cur;  
    int mid=(l+r)/2;  
    if(p<=mid)ls[cur]=change(ls[cur],l,mid);  
    else rs[cur]=change(rs[cur],mid+1,r);  
    return cur;  
}  
int find(int x,int y,int l,int r,int k)  
{  
    int ans;int mid=(l+r)/2;  
    int qwq=sum[ls[y]]-sum[ls[x]];  
    if(l==r)return l;  
    if(qwq>=k)ans=find(ls[x],ls[y],l,mid,k);  
    else ans=find(rs[x],rs[y],mid+1,r,k-qwq);  
    return ans;  
}  
int main()  
{  
    scanf("%d%d",&n,&m);  
    for(int i=1;i<=n;++i)  
    {  
        scanf("%d",&a[i]);  
        num[i]=a[i];  
    }  
    sort(num+1,num+1+n);  
    int q=unique(num+1,num+1+n)-num;  
    q-=1;  
    build(rt[0],1,q);  
    for(int i=1;i<=n;++i)  
    {  
        p=lower_bound(num+1,num+1+q,a[i])-num;  
        rt[i]=change(rt[i-1],1,q);  
    }  
    for(int i=1;i<=m;++i)  
    {  
        int x,y,z;  
        scanf("%d%d%d",&x,&y,&z);  
        int qwq=find(rt[x-1],rt[y],1,q,z);  
        printf("%d\n",num[qwq]);  
    }  
    return 0;  
}  
```

#### 4. vector实现Treap
1.  插入 x 数
2.  删除 x 数(若有多个相同的数，应只删除一个)
3.  查询 x 数的排名(排名定义为比当前数小的数的个数 +1 )
4.  查询排名为 x 的数
5.  求 x 的前驱(前驱定义为小于 x，且最大的数)
6.  求 x 的后继(后继定义为大于 x，且最小的数)
```cpp
cin>>n;
	for(int i=1;i<=n;++i)
	{
		int k,x;
		cin>>k>>x;
		if(k==1)
			tree.insert(lower_bound(tree.begin(),tree.end(),x),x);
		else if(k==2)
			tree.erase(lower_bound(tree.begin(),tree.end(),x));
		else if(k==3)
		{
			int p=lower_bound(tree.begin(),tree.end(),x)-tree.begin();
			cout<<p+1<<endl;
		}
		else if(k==4)
			cout<<tree[x-1]<<endl;
		else if(k==5)
		{
			int p=lower_bound(tree.begin(),tree.end(),x)-tree.begin();
			cout<<tree[p-1]<<endl;
		}
		else if(k==6)
		{
			int p=upper_bound(tree.begin(),tree.end(),x)-tree.begin();
			cout<<tree[p]<<endl;
		}
	}
```



#### 5. 最短路

- dijkstra

```C++ 
void dij(int s)
{
	priority_queue<pot>q;
	for(int i=1;i<=n;++i)dis[i]=2147483647;
	dis[s]=0;
	cur.num=s;cur.dis=0;
	q.push(cur);
	while(!q.empty())
	{
		cur=q.top();
		q.pop();
		if(vis[cur.num])continue;
		vis[cur.num]=1;
		for(int i=head[cur.num];i;i=edge[i].next)
		{
			int t=edge[i].to;
			if(!vis[t]&&(dis[t]>cur.dis+edge[i].val))
			{
				nxt.num=t;
				dis[t]=nxt.dis=cur.dis+edge[i].val;
				q.push(nxt);
			}
		}
	}
}
```

- spfa

```C++
void spfa()
{
	memset(vis,0,sizeof(vis));
	queue<int>q;
	vis[s]=1;
	dis[s]=0;
	q.push(s);
	while(!q.empty())
	{
		int cur=q.front();
		q.pop();
		vis[cur]=0;
		for(int i=head[cur];i;i=edge[i].nxt)
		{
			int nxt=edge[i].to;
			if(dis[nxt]>dis[cur]+edge[i].val)
			{
				dis[nxt]=dis[cur]+edge[i].val;
				if(vis[nxt])continue;
				vis[nxt]=1;
				q.push(nxt);
			}
		}
	}
}
```

- floyd

```C++
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			for(int k=1;k<=n;++k)
				if(i!=j&&i!=k&&k!=j)dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
```

- 倍增floyd

```C++ 
int f[101][101][50],ans[1001][1001];
//ans[i][j]为i到j的最短路，f[i][j][k]表示i到j的路径上是否存在长度为2^k的路径
int main()
{
	scanf("%d%d",&n,&m);
	memset(ans,0x3f,sizeof(ans));
	for(int i=1;i<=m;++i)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		f[x][y][0]=1;
		ans[x][y]=1;
	}
	for(int i=1;i<=n;++i)ans[i][i]=0;
	for(int s=1;s<=20;++s)//枚举次方
	{
		for(int i=1;i<=n;++i)
		{
			for(int j=1;j<=n;++j)
			{
				for(int k=1;k<=n;++k)
				{
					if(f[i][k][s-1]&&f[k][j][s-1])
					{
						f[i][j][s]=1;
						ans[i][j]=1;
						if(i==j)ans[i][j]=0;
					}
				}
			}
		}
	}
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			for(int k=1;k<=n;++k)
				if(i!=j&&i!=k&&k!=j)ans[i][j]=min(ans[i][j],ans[i][k]+ans[k][j]);
	printf("%d",ans[1][n]);
	return 0;
}
```

- 全源最短路

```c++
int head[100100],dis[100100],h[100100],vis[100100],tot[100100];
struct node{
	int from,nxt,to,val;
}edge[200200];
void add(int from,int to,int w)
{
	edge[++cnt].nxt=head[from];
	edge[cnt].from=from;
	edge[cnt].to=to;
	edge[cnt].val=w;
	head[from]=cnt;
}
bool spfa(int s)
{
	queue<int>q;
	memset(h,0x3f,sizeof(h));
	memset(vis,0,sizeof(vis));
	memset(tot,0,sizeof(tot));
	h[s]=0;
	vis[s]=1;
	q.push(s);
	while(!q.empty())
	{
		int cur=q.front();
		q.pop();
		vis[cur]=0;
		if(tot[cur]>n)return false;
		for(int i=head[cur];i;i=edge[i].nxt)
		{
			int nxt=edge[i].to;
			if(h[nxt]>h[cur]+edge[i].val)
			{
				h[nxt]=h[cur]+edge[i].val;
				if(vis[nxt])continue;
				vis[nxt]=1;
				q.push(nxt);
				++tot[nxt];
			}
		}
	}
	return true;
}
void dij(int s)
{
	priority_queue<pair<int,int> >q;
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[s]=0;
	q.push(make_pair(0,s));
	while(!q.empty())
	{
		int cur=q.top().second;
		q.pop();
		if(vis[cur])continue;
		vis[cur]=1;
		for(int i=head[cur];i;i=edge[i].nxt)
		{
			int nxt=edge[i].to;
			if(vis[nxt])continue;
			if(dis[nxt]>dis[cur]+edge[i].val)
			{
				dis[nxt]=dis[cur]+edge[i].val;
				q.push(make_pair(-dis[nxt],nxt));
			}
		}
	}
}
signed main()//spfa计算h数组，dij计算dis数组，根据差值计算最短路
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;++i)add(0,i,0);
	for(int i=1;i<=m;++i)
	{
		int x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		add(x,y,z);
	}
	int f=spfa(0);
	if(!f)
	{
		printf("-1");
		return 0;
	}
	for(int i=1;i<=n;++i)
	{
		for(int j=head[i];j;j=edge[j].nxt)
		{
			int nxt=edge[j].to;
			edge[j].val+=h[i]-h[nxt];
		} 
	}
	for(int i=1;i<=n;++i)
	{
		dij(i);
		int ans=0;
		for(int j=1;j<=n;++j)
		{
			if(dis[j]>=inf)ans+=j*1e9;
			else ans+=(dis[j]+h[j]-h[i])*j;
		}
		printf("%lld\n",ans);
	}
	return  0;
}
```

#### 6. 判负环

- dfs版spfa判负环（推荐）

```C++ 
bool spfa(int cur)
{
	vis[cur]=1;
	for(int i=head[cur];i;i=edge[i].nxt)
	{
		int nxt=edge[i].to;
		if(dis[nxt]<=dis[cur]+w)continue;
		dis[nxt]=dis[cur]+w;
		if(vis[nxt]||spfa(nxt))return 1;
	}
	vis[cur]=0;
	return 0;
}
```

- bfs版spfa判负环（会慢）

```C++
void spfa(int s)  
{  
    queue<int>q;  
    dis[s]=0;  
    q.push(s);  
    vis[s]=1;  
    while(!q.empty())  
    {  
        int cur=q.front();  
        q.pop();  
        vis[cur]=0;  
        ++tank[cur];  
        if(tank[cur]>n*2)  
        {  
           flag=1;  
           return;  
        }  
        for(int i=head[cur];i;i=edge[i].nxt)  
           if(dis[edge[i].to]>dis[cur]+edge[i].value)  
           {  
               dis[edge[i].to]=dis[cur]+edge[i].value;  
               if(!vis[edge[i].to])  
               {  
                   vis[edge[i].to]=1;  
                   q.push(edge[i].to);  
               }  
           }  
    }  
}  
```

#### 7. Tarjan全家桶

- 强连通分量

```C++
  void tarjan(int cur)  
  {  
    dfn[cur]=low[cur]=++tot;  
    vis[cur]=1;  
    s.push(cur);  
    for(int i=head[cur];i;i=edge[i].nxt)  
    {  
        int nxt=edge[i].to;  
        if(!dfn[nxt])  
        {  
            tarjan(nxt);  
            low[cur]=min(low[cur],low[nxt]);  
        }  
        else if(vis[nxt])low[cur]=min(low[cur],dfn[nxt]);  
    }  
    int now=-1;  
    if(low[cur]==dfn[cur])  
    {  
        ++sum;  
        do  
        {  
            now=s.top();  
            s.pop();  
            vis[now]=0;  
            fa[now]=sum;  
        }while(cur!=now);  
    }  
  }  
```

- 割点

```C++
  void tarjan(int s,int fa)  
  {  
    int son=0;  
    low[s]=dfn[s]=++tot;  
    for(int i=head[s];i;i=edge[i].nxt)  
    {  
        int nxt=edge[i].to;  
        if(!dfn[nxt])  
        {  
            tarjan(nxt,fa);  
            low[s]=min(low[s],low[nxt]);  
            if(low[nxt]>=dfn[s]&&s!=fa)vis[s]=1;//割点被打标记了            
            if(s==fa)++son;  
        }  
        low[s]=min(low[s],dfn[nxt]);  
    }  
    if(s==fa&&son>=2)vis[fa]=1;  
  }  

```

#### 8. 差分约束系统

- 常规
  - 如果 X=1， 表示第 A 个小朋友分到的糖果必须和第 B 个小朋友分到的糖果一样多；
  - 如果 X=2， 表示第 A 个小朋友分到的糖果必须少于第 B 个小朋友分到的糖果；
  - 如果 X=3， 表示第 A 个小朋友分到的糖果必须不少于第 B 个小朋友分到的糖果；
  - 如果 X=4， 表示第 A 个小朋友分到的糖果必须多于第 B 个小朋友分到的糖果；
  - 如果 X=5， 表示第 A 个小朋友分到的糖果必须不多于第 B 个小朋友分到的糖果

```C++ 
bool spfa(int s)//实际上是在用spfa判负环
{
	queue<int>q;	
	memset(dis,0x3f,sizeof(dis));
	memset(tot,0,sizeof(tot));
	dis[s]=0;
	vis[s]=1;
	q.push(s);
	while(!q.empty())
	{
		int cur=q.front();
		q.pop();
		vis[cur]=0;
		if(tot[cur]>n)return false;
		for(int i=head[cur];i;i=edge[i].nxt)
		{
			int nxt=edge[i].to;
			if(dis[nxt]>dis[cur]+edge[i].val)
			{
				dis[nxt]=dis[cur]+edge[i].val;
				if(!vis[nxt])
				{
					vis[nxt]=1;
					++tot[nxt];
					q.push(nxt);
				}
			}
		}
	}
	return true;
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;++i)
	{
		int k,x,y;
		scanf("%lld%lld%lld",&k,&x,&y);
		if(k==1)//相同时建立双向边，边权为0
		{
			add(x,y,0);
			add(y,x,0);
		}
		else if(k==2)add(x,y,1);//小于时x到y建边
		else if(k==3)add(y,x,0);
		else if(k==4)add(y,x,1);//大于时y到x建边
		else if(k==5)add(x,y,0);
	}
	for(int i=1;i<=n;++i)add(0,i,0);
	int f=spfa(0);
	if(!f)
	{
		printf("-1");
		return 0;
	}
	for(int i=1;i<=n;++i)ans+=dis[i];
	printf("%lld",ans);
	return 0;
}
```

- 当边权都为0或1时，SPFA可能会被卡掉，此处可以先用Tarjan将边全为0的边用缩点去掉，重新见图后用拓扑排序判断是否为DAG即可

```C++
void tarjan(int cur)
{
	dfn[cur]=low[cur]=++tot;
	vis[cur]=1;
	s[++top]=cur;
	for(int i=head[cur];i;i=edge[i].nxt)
	{
		int nxt=edge[i].to;
		if(!dfn[nxt])
		{
			tarjan(nxt);
			low[cur]=min(low[cur],low[nxt]);
		}
		else if(vis[nxt])low[cur]=min(low[cur],low[nxt]);
	}
	int now=-1;
	if(low[cur]==dfn[cur])
	{
		++sum;
		while(cur!=now&&top)
		{
			now=s[top];
			--top;
			vis[now]=0;
			++siz[sum];
			fa[now]=sum;
		}
	}
}
void bfs()
{
	queue<int>q;
	for(int i=1;i<=sum;++i)
		if(!in[i])
		{
			dis[i]=1;
			q.push(i);
		}
	while(!q.empty())
	{
		int cur=q.front();
		q.pop();
		for(int i=head2[cur];i;i=edge2[i].nxt)
		{
			int nxt=edge2[i].to;
			--in[nxt];
			if(dis[nxt]<dis[cur]+edge2[i].w)
			{
				dis[nxt]=dis[cur]+edge2[i].w;
			}
			if(!in[nxt])q.push(nxt);
		}
	}
}
signed main()
{
	scanf("%d%d",&n,&m);
    //建边的代码见上
	for(int i=1;i<=n;++i)
		if(!dfn[i])tarjan(i);
	for(int i=1;i<=n;++i)
		for(int j=head[i];j;j=edge[j].nxt)
		{
			int nxt=edge[j].to;
			if(fa[i]==fa[nxt])
			{
				tmp[fa[i]]+=edge[j].w;
				if(tmp[fa[i]])//tmp[i]记录第i个连通分量内部的边权和，如果为1说明缩点出问题了
				{
					printf("-1");
					return 0;					
				}
			}
			else 
			{
				add(fa[i],fa[nxt],edge[j].w,edge2,cnt1,head2);
				++in[fa[nxt]];
			}
		}
	memset(vis,0,sizeof(vis));
	bfs();
	long long ans=0;
	for(int i=1;i<=sum;++i)ans+=dis[i]*siz[i];
	printf("%lld",ans);
	return 0;
}
```

#### 9. 分层图

```C++
for(int i=1;i<=m;++i)  
    {  
        int x,y,z;  
        scanf("%d%d%d",&x,&y,&z);  
        for(int j=0;j<=k;++j)  
        {  
           add(x+n*j,y+n*j,z);  
           add(y+n*j,x+n*j,z);  
           if(j<k)  
           {  
               add(x+n*j,y+n*(j+1),z/2);  
               add(y+n*j,x+n*(j+1),z/2);  
           }  
        }  
    }  
```

#### 10. 01分数规划

- 基本格式：

给你 $n$ 个物品，每个物品有两个属性 $a_i$ 和 $b_i$，求一组解 $x_i(1\le i\le n, x_i=0 或 1)$ 使


$$
\large\frac{\Sigma_{i=1}^{n}a_i\times x_i}{\Sigma_{i=1}^{n}b_i\times x_i}
$$

最大，且恰好有 k 个 $x_i$为 1

```C++
bool check(double qwq) {
    priority_queue<double>q;
    for (int i = 1; i <= n; ++i)
        q.push(1.0 * a[i] - (qwq * b[i]));
    double sum = 0;
    for (int i = 1; i <= k; ++i) {
        sum += q.top();
        q.pop();
    }
    return sum >= 0;
}
int main() {
    while (r - l > emp) {
        double mid = (l + r) / 2;
        if (check(mid)) {
            ans = mid;
            l = mid;
        } else r = mid;
    }
    printf("%.4lf", ans);
}
```

- 01分数规划+图论

考虑带权的有向图$G=(V,E)$以及$w:E\rightarrow R$,每条边$e=(i,j)(i\neq j,i\in V,j\in V)$的权值定义为$w_{i,j}$，令$n=|V|$。$c=(c_1,c_2,\cdots,c_k)(c_i\in V)$是$G$中的一个圈当且仅当$(c_i,c_{i+1})(1\le i<k)$和$(c_k,c_1)$都在$E$中，这时称$k$为圈$c$的长度同时令$c_{k+1}=c_1$，并定义圈$c=(c_1,c_2,\cdots,c_k)$的平均值为$\mu(c)=\sum\limits_{i=1}^{k} w_{c_i,c_{i+1}}/k$，即$c$上所有边的权值的平均值。令$\mu'(c)=Min(\mu(c))$为$G$中所有圈$c$的平均值的最小值。现在的目标是：在给定了一个图$G=(V,E)$以及$w:E\rightarrow R$之后，请求出$G$中所有圈$c$的平均值的最小值$\mu'(c)=Min(\mu(c))$

```C++
bool spfa(int cur,double mid)//spfa判负环
{
	vis[cur]=1;
	for(int i=head[cur];i;i=edge[i].nxt)
	{
		int nxt=edge[i].to;
		double w=edge[i].val-mid;
		if(dis[nxt]<=dis[cur]+w)continue;
		dis[nxt]=dis[cur]+w;
		if(vis[nxt]||spfa(nxt,mid))return 1;
	}
	vis[cur]=0;
	return 0;
}
bool check(double qaq)//修改边权，查看是否有负环
{
	memset(dis,0,sizeof(dis));
	memset(vis,0,sizeof(vis));
	for(int i=1;i<=n;++i)
		if(spfa(i,qaq))return 1;
	return 0;
}
int main()
{
	scanf("%d%d",&n,&m);
	double l=-1e6,r=1e6;
	for(int i=1;i<=m;++i)
	{
		int x,y;
		double z;
		scanf("%d%d%lf",&x,&y,&z);
		add(x,y,z);
	}
	while(r-l>emp)
	{
		double mid=(l+r)/2;
		if(check(mid))
		{
			r=mid;
		}
		else l=mid;
	}
	printf("%.8lf",l);
	return 0;
}
```

#### 11.并查集

- 按秩合并

```C++
int find(int k)
{
    return fa[k]==k?k:find(fa[k]);
}
void unite(int x,int y)
{
    x=find(x);
    y=find(y);
    if(x==y) return ;
    if(rank[x]<rank[y])
        fa[x]=y;  // 合并是从rank小的向rank大的连边
    else
    {
        fa[y]=x;
        if(rank[x]==rank[y]) rank[x]++;
    }
}
```

- 带权并查集

```C++
int find(int k)//sun[k]表示k点所在集合内点权的和
{
	if(fa[k]==k||fa[k]==fa[fa[k]])return fa[k];
	int cur=find(fa[k]);
	sum[k]+=sum[fa[k]];
	return fa[k]=cur;	
}
void merge(int x,int y)
{
	int xx=find(x),yy=find(y);
	if(xx!=yy)
	{
		sum[xx]-=sum[yy];
		fa[xx]=yy;
	}
}
```

#### 12. 最小生成树

- prim

```C++
void prim(int s)
{
	priority_queue<dot>q;
	cur.dis=0;cur.num=s;
	q.push(cur);
	while(!q.empty())
	{
		cur=q.top();
		q.pop();
		if(vis[cur.num])continue;
		vis[cur.num]=1;
		ans+=cur.dis;
		for(int i=head[cur.num];i;i=edge[i].nxt)
		{
			int nx=edge[i].to;
			if(vis[nx])continue;
			nxt.dis=edge[i].val;
			nxt.num=nx;
			q.push(nxt);
		}
	}
}
```

- kruskal

```C++
int Find(int x)
{
    if(p[x]!=x) p[x]=Find(p[x]);
    return p[x];
}
int kruskal()
{
    sort(edge,edge+m);
    for(int i=1;i<=n;++i) p[i]=i;
    int res=0,cnt=0;
    for(int i=1;i<=m;++i)
    {
        int a=edge[i].a,b=edge[i].b,w=edge[i].w;
        a=Find(a),b=Find(b);
        if(a!=b)
        {
            p[a]=b;
            res+=w;
            cnt++;
        }
    }
    if(cnt<n-1) return INF;
    return res;
}
```

#### 13. 字典树

- 查询单词是否出现

```C++
int n,m,tot;
int tree[N][30],vis[N*26];
string s;
void build(string  s)//插入字符串
{
	int l=s.size();
	int cur=1;
	for(int i=0;i<l;++i)
	{
		int tmp=s[i]-'a';
		if(!tree[cur][tmp])tree[cur][tmp]=++tot;
		cur=tree[cur][tmp];
	}
}
int find(string s)//查询单词是否出现，0为未出现，1为出现
{
	int l=s.size();
	int cur=1;
	for(int i=0;i<l;++i)
	{
		int tmp=s[i]-'a';
		if(!tree[cur][tmp])return 0;
		cur=tree[cur][tmp];
	}
	return 1;
}

```

- 最长异或路径

给定一棵 $n$ 个点的带权树，结点下标从 $1$ 开始到 $n$。寻找树中找两个结点，求最长的异或路径。

异或路径指的是指两个结点之间唯一路径上的所有边权的异或。

```C++
int n,cnt,tot,ans;
int head[100100],num[100100];
int tree[1001000][2];
void dfs(int s,int fa)
{
	for(int i=head[s];i;i=edge[i].nxt)
	{
		int nxt=edge[i].to;
		if(nxt==fa)continue;
		num[nxt]=num[s]^edge[i].val;//更新从根节点到该节点的异或和
		dfs(nxt,s);
	}
}
void insert(int x)//插入一个值
{
	int cur=0;
	for(int i=30;i>=0;--i)
	{
		int tmp=(x>>i)&1;
		if(!tree[cur][tmp])tree[cur][tmp]=++tot;
		cur=tree[cur][tmp];
	}
}
int find(int x)
{
	int cur=0,ans=0;
	for(int i=30;i>=0;--i)
	{
		int tmp=(x>>i)&1;
		if(tree[cur][!tmp])//如果与x的第i位不同的数存在，前往查询
		{
			ans+=(1<<i);
			cur=tree[cur][!tmp];
		}
		else cur=tree[cur][tmp];
	}
	return ans;
}
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<n;++i)
	{
		int x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		add(x,y,z);
		add(y,x,z);
	}
	dfs(1,0);
	for(int i=1;i<=n;++i)insert(num[i]);
	for(int i=1;i<=n;++i)ans=max(ans,find(num[i]));
	printf("%lld",ans);
	return 0;
}
```

